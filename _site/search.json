[
  {
    "objectID": "In-Class_Ex/In-Class_Ex_5/MC1.html",
    "href": "In-Class_Ex/In-Class_Ex_5/MC1.html",
    "title": "In-Class Exercise 05",
    "section": "",
    "text": "MC 01\npacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph)\nkg &lt;- fromJSON(\"data/MC1_graph.json\")"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex_5/MC1.html#initial-eda",
    "href": "In-Class_Ex/In-Class_Ex_5/MC1.html#initial-eda",
    "title": "In-Class Exercise 05",
    "section": "Initial EDA",
    "text": "Initial EDA\n\nggplot(data = edges_tbl, aes(y = `Edge Type`)) + \n  geom_bar()"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex_5/MC1.html#creating-knowledge-graph",
    "href": "In-Class_Ex/In-Class_Ex_5/MC1.html#creating-knowledge-graph",
    "title": "In-Class Exercise 05",
    "section": "Creating knowledge graph",
    "text": "Creating knowledge graph\n\nStep 1: Mapping from node id to row index\n\nid_map &lt;- tibble(id = nodes_tbl$id, index = seq_len(nrow(nodes_tbl)))\n\n\n\nStep 2: Map source and target IDs to row indices\n\nedges_tbl &lt;- edges_tbl %&gt;%\n  left_join(id_map, by = c(\"source\" = \"id\"), suffix = c(\"\", \"_source\")) %&gt;%\n  rename(from = index) %&gt;%\n  left_join(id_map, by = c(\"target\" = \"id\"), suffix = c(\"\", \"_target\")) %&gt;%\n  rename(to = index)\n\n\n\nStep 3\n\nedges_tbl &lt;- edges_tbl %&gt;%\n  filter(!is.na(from), !is.na(to))\n\n\n\nStep 4: Creating the graph\n\ngraph &lt;- tbl_graph(nodes = nodes_tbl, edges = edges_tbl, \n                   directed = kg$directed)"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex_5/MC1.html#visualizing-the-knowledge-graph",
    "href": "In-Class_Ex/In-Class_Ex_5/MC1.html#visualizing-the-knowledge-graph",
    "title": "In-Class Exercise 05",
    "section": "Visualizing the knowledge graph",
    "text": "Visualizing the knowledge graph\n\nset.seed(1234)\n\n\nVisualizing the whole Graph\n\nggraph(graph, layout = \"fr\") + \n  geom_edge_link(alpha = 0.3, colour = \"gray\") +\n  geom_node_point(aes(color = `Node Type`), size = 4) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 2.5) +\n  theme_void()\n\n\nStep 1: Filter edges to only “MemberOf”\n\ngraph_memberof &lt;- graph %&gt;%\n  activate(edges) %&gt;%\n  filter(`Edge Type` == \"MemberOf\")\n\n\n\nStep 2: Extract only connected nodes (ie. used in these edges)\n\nused_node_indices &lt;- graph_memberof %&gt;%\n  activate(edges) %&gt;%\n  as_tibble() %&gt;%\n  select(from, to) %&gt;%\n  unlist() %&gt;%\n  unique()\n\n\n\nStep 3: Keep only those nodes\n\ngraph_memberof &lt;- graph_memberof %&gt;%\n  activate(nodes) %&gt;%\n  mutate(row_id = row_number()) %&gt;%\n  filter(row_id %in% used_node_indices) %&gt;%\n  select(-row_id)  #optional cleanup\n\n\n\nPlot the sub-graph\n\nggraph(graph_memberof, layout = \"fr\") + \n  geom_edge_link(alpha = 0.5, colour = \"gray\") +\n  geom_node_point(aes(color = `Node Type`), size = 1) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 2.5) +\n  theme_void()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS608-VAA",
    "section": "",
    "text": "Welcome to ISSS608 Visual Analytics and Applications. In this website, you will find my coursework prepared for this course.\nThe Reference materials used can be found in Prof Kam Tin Seong’s course Webpage.\nhttps://isss608-ay2024-25apr.netlify.app/"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1B/Take-home_Ex01B.html",
    "href": "Take-home_Ex/Take-home_Ex_1B/Take-home_Ex01B.html",
    "title": "Take-home Exercise 01B",
    "section": "",
    "text": "Phase 2: to select one submission provided by a classmate, critic three good design principles and three areas for further improvement. With reference to the comment, prepare the makeover version of the data visualisation. I am selecting this submission from other classmate, as shown here.\n\n\nThe data should be processed by using appropriate tidyverse family of packages and the data visualisation must be prepared using ggplot2 and its extensions.\n\npacman::p_load(ggrepel, patchwork, \n               ggthemes, hrbrthemes,\n               tidyverse, ggplot2) \n\n\n\n\nTo accomplish the task, Singapore Residents by Planning Area / Subzone, Single Year of Age and Sex, June 2024 dataset shared by Department of Statistics, Singapore (DOS) will be used and we wil load it as follows:\n\npop_data &lt;- read_csv(\"data/respopagesex2024.csv\", col_names = TRUE)\n\n\n\n\n\n\nOriginal Data Visualization:\n\npyramid_data &lt;- pop_data %&gt;%\n  group_by(Age, Sex) %&gt;%\n  summarise(Pop = sum(Pop), .groups = \"drop\") %&gt;%\n  mutate(Pop = ifelse(Sex == \"Males\", -Pop, Pop))\n\nggplot(pyramid_data, aes(x = Age, y = Pop, fill = Sex)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() +\n  scale_y_continuous(labels = abs) +\n  scale_fill_manual(values = c(\"Males\" = \"#102E50\", \"Females\" = \"#F7CFD8\")) + \n  scale_x_discrete(breaks = seq(0, 100, by = 10)) +\n  labs(title = \"Singapore Age Pyramid (2024)\",\n       x = \"Age\", y = \"Population\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nComments:\nThree good design principles:\n\nDifferent contrast colours are used to differentiate between Males and Females Resident count\nAppropriate use of chart (pyramid chart) instead of points to represent discrete values\nClear labeling for chart title, legend, x axis title and y axis title\n\nThree areas for further improvement:\n\nAxis Labeling and Scale Consistency\nConfusing x axis (starts from 0) and y axis (0 starts from the center) labeling. And, the distance between 0 to 10 to 20 on the y-axis is not consistent which signalling there is an error in the data preparation. The y-axis values ranges from 0 mark to 80 mark, whereas the dataset for Age ranges from 0 to 90+. There should be a 90 mark in the y-axis to represent the clearer and more accurate representation of the chart.\nGraphical Integrity: The top chart shows 2 wide bars after tapering off of the top pyramid which is not a true representation of the dataset. There should be a data cleaning performed before the visualization to change the data type for Age column from strings to integer and there is 1 value in the Age column: 90_and_Over that needs to be recoded to a numeric number. The lack of data preparation has led to the wrong representation of the data in this chart.\nGroup Ages into 5-Year Bins: The current age pyramid displays age in single-year intervals, resulting in a visually dense and harder-to-read chart. Binning the ages into 5-year groups (e.g., 0–4, 5–9, …, 85–89, 90+) would simplify the structure and highlight broader population trends more effectively. Additionally, including a vertical line to indicate the median age would provide a valuable reference point, making it easier to interpret the overall age distribution and identify demographic imbalance\n\nMakeover version of the Chart\nSome data preparation is needed: - to make the age group of interval 5 years from 0 to 90+ - to change the data type of Age from character to numeric\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\n\n# Data preparation\npyramid_data &lt;- pop_data %&gt;%\n  mutate(Age = ifelse(Age == \"90_and_Over\", \"91\", Age),\n         Age = as.numeric(Age)) %&gt;%\n  filter(!is.na(Age)) %&gt;%\n  mutate(AgeGroup = cut(Age,\n                        breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45,\n                                   50, 55, 60, 65, 70, 75, 80, 85, 90, Inf),\n                        right = TRUE,\n                        include.lowest = TRUE,\n                        labels = c(\"0–5\", \"6–10\", \"11–15\", \"16–20\", \"21–25\",\n                                   \"26–30\", \"31–35\", \"36–40\", \"41–45\", \"46–50\",\n                                   \"51–55\", \"56–60\", \"61–65\", \"66–70\", \"71–75\",\n                                   \"76–80\", \"81–85\", \"86–90\", \"90+\"))) %&gt;%\n  group_by(AgeGroup, Sex) %&gt;%\n  summarise(Pop = sum(Pop, na.rm = TRUE), .groups = \"drop\") %&gt;%\n  mutate(Pop = ifelse(Sex == \"Males\", -Pop, Pop),\n         Label = comma(abs(Pop), accuracy = 1),\n         Rank = dense_rank(desc(AgeGroup)))\n\nmedian_group &lt;- pyramid_data %&gt;%\n  group_by(AgeGroup) %&gt;%\n  summarise(TotalPop = sum(abs(Pop))) %&gt;%\n  mutate(CumSum = cumsum(TotalPop),\n         MedianFlag = CumSum &gt;= sum(TotalPop) / 2) %&gt;%\n  filter(MedianFlag) %&gt;%\n  slice(1) %&gt;%\n  pull(AgeGroup)\n\n# Plot\nggplot(pyramid_data, aes(x = AgeGroup, y = Pop, fill = Sex)) +\n  geom_bar(stat = \"identity\", width = 0.9) +\n  geom_text(aes(label = Label,\n              hjust = case_when(\n                AgeGroup %in% c(\"90+\", \"86–90\") & Sex == \"Males\" ~ 1.1,\n                AgeGroup %in% c(\"90+\", \"86–90\") & Sex == \"Females\" ~ -0.1,\n                Sex == \"Males\" ~ 0,  # centered inside left bar\n                Sex == \"Females\" ~ 1.5  # centered inside right bar\n              )),\n          size = 3, color = \"black\") +  # &lt;- Added the missing plus sign here\n  geom_vline(xintercept = 0, color = \"black\") +\n  coord_flip() +\n  scale_y_continuous(labels = NULL, breaks = NULL) +  # Remove x-axis tick values\n  scale_fill_manual(values = c(\"Males\" = \"#7EC8E3\", \"Females\" = \"#F7CFD8\")) +\n  labs(title = \"Singapore Population Age Pyramid (2024)\",\n       x = \"Age Group (Years)\", y = NULL, fill = \"Sex\") +\n  theme_minimal(base_size = 11) +\n  theme(plot.title = element_text(size = 14, face = \"bold\"),\n        axis.text.y = element_text(size = 9),\n        panel.grid.major.y = element_blank(),\n        legend.position = \"right\") +\n  annotate(\"text\", x = median_group, y = 0,\n           label = paste(\"Median:\", median_group),\n           vjust = -0.8, fontface = \"italic\", color = \"gray40\", size = 4)\n\n\n\n\n\n\n\nOriginal Visualization:\n\nlibrary(tidyverse)\n\n# Summarise total and elderly population by PA\ntop_areas &lt;- pop_data %&gt;%\n  group_by(PA) %&gt;%\n  summarise(\n    Total = sum(Pop),\n    Elderly = sum(Pop[Age &gt;= 65]),\n    .groups = \"drop\"\n  ) %&gt;%\n  \n  top_n(15, Total)  # or 20 if you prefer\n\n# Reshape into long format for grouped bars\nplot_data &lt;- top_areas %&gt;%\n  pivot_longer(cols = c(Total, Elderly),\n               names_to = \"Type\",\n               values_to = \"Population\") %&gt;%\n  mutate(\n    Type = recode(Type,\n                  \"Total\" = \"Total Population\",\n                  \"Elderly\" = \"Elderly (65+)\")\n  )\n# Reorder PA by Total Population (not elderly)\nplot_data &lt;- plot_data %&gt;%\n  left_join(top_areas %&gt;% select(PA, Total), by = \"PA\") %&gt;%\n  mutate(PA = fct_reorder(PA, Total, .desc = FALSE))  # use forcats::fct_reorder\n\nggplot(plot_data, aes(x = PA, y = Population, fill = Type)) +\n  geom_col(position = \"dodge\") +\n  geom_text(aes(label = scales::comma(Population)),\n            position = position_dodge(width = 0.9), hjust = -0.1, size = 3) +\n  scale_y_continuous(labels = scales::comma,\n                     expand = expansion(mult = c(0, 0.15))) +\n  scale_fill_manual(values = c(\"Total Population\" = \"#8E7DBE\", \"Elderly (65+)\" = \"#EFC000\")) +\n  coord_flip() +\n  labs(\n    title = \"Total vs Elderly Population in Top Planning Areas (2024)\",\n    x = \"Planning Area\",\n    y = \"Population\",\n    fill = \"\"\n  ) +\n  theme_classic()\n\n\n\n\n\n\n\n\nComments:\nThree good design principles:\n\nEffective use of contrast colours are used to differentiate between the total population and elderly population count by planning areas\nClear notation of the data values inside the chart\nClear labeling for legend, x axis and y axis title and mark.\n\nThree areas for further improvement\n\nThe chart currently includes both detailed bar annotations and x-axis tick marks, which introduces visual redundancy. When values are already clearly displayed inside or beside the bars, retaining dense tick marks on the x-axis adds clutter without enhancing interpretability. It is advisable to choose either to annotate values inside the chart or to rely on well-spaced x-axis tick marks—not both. Removing one will streamline the visual presentation and improve focus on the data.\nMisleading data due to insufficient data cleaning and preparation. The chart reflects inaccurate figures—e.g., Bedok’s elderly population is overstated as 70,130 instead of the correct 62,990—due to lack of data preparation. Proper data cleaning, including converting the Age column to numeric and recoding “90_and_Over” as 90, is essential to ensure data integrity and reliable insights.\nSorting and chart type The chart should be sorted by elderly population, not total population, to match its stated purpose. Using a stacked bar chart (rather than side-by-side horizontal barbars) would better show the elderly count in relation to the total population within each planning area.\n\nMakeover version of the Chart\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Data Preparation\npop_data &lt;- pop_data %&gt;%\n  mutate(\n    Age = str_trim(Age),\n    Age = case_when(\n      Age == \"90_and_Over\" ~ \"90\",\n      str_detect(Age, \"^[0-9]+$\") ~ Age,\n      TRUE ~ NA_character_\n    ),\n    Age = as.numeric(Age)\n  )\n\n\ntop_areas &lt;- pop_data %&gt;%\n  group_by(PA) %&gt;%\n  summarise(\n    Total = sum(Pop, na.rm = TRUE),\n    Elderly = sum(Pop[Age &gt;= 65], na.rm = TRUE),\n    .groups = \"drop\"\n  ) %&gt;%\n  slice_max(Elderly, n = 20)\n\n# Prepare data\nplot_data &lt;- top_areas %&gt;%\n  mutate(NonElderly = Total - Elderly) %&gt;%\n  select(PA, Elderly, NonElderly) %&gt;%\n  pivot_longer(cols = c(Elderly, NonElderly),\n               names_to = \"Group\",\n               values_to = \"Population\") %&gt;%\n  mutate(Group = recode(Group,\n                        \"Elderly\" = \"Elderly (65+)\",\n                        \"NonElderly\" = \"Non-Elderly\"),\n         Group = factor(Group, levels = c(\"Non-Elderly\", \"Elderly (65+)\"))) %&gt;%\n  left_join(top_areas %&gt;% select(PA, Elderly), by = \"PA\") %&gt;%\n  mutate(PA = fct_reorder(PA, Elderly, .desc = FALSE))  \n\n# Plot\nggplot(plot_data, aes(x = PA, y = Population, fill = Group)) +\n  geom_col(width = 0.9) +\n  scale_y_continuous(\n    breaks = seq(25000, 300000, by = 25000),\n    labels = function(x) x / 1000,  # Show in '000\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_fill_manual(values = c(\n    \"Non-Elderly\" = \"#A6D1E6\",\n    \"Elderly (65+)\" = \"#FFB347\"\n  )) +\n  coord_flip() +\n  labs(\n    title = \"Top 20 PA by Elderly Population Count (Age 65+)\",\n    x = \"Planning Area\",\n    y = \"Population (in '000)\",\n    fill = \"\"\n  ) +\n  theme_classic(base_size = 12) +\n  theme(legend.position = \"right\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1B/Take-home_Ex01B.html#the-designing-tool",
    "href": "Take-home_Ex/Take-home_Ex_1B/Take-home_Ex01B.html#the-designing-tool",
    "title": "Take-home Exercise 01B",
    "section": "",
    "text": "The data should be processed by using appropriate tidyverse family of packages and the data visualisation must be prepared using ggplot2 and its extensions.\n\npacman::p_load(ggrepel, patchwork, \n               ggthemes, hrbrthemes,\n               tidyverse, ggplot2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1B/Take-home_Ex01B.html#import-data",
    "href": "Take-home_Ex/Take-home_Ex_1B/Take-home_Ex01B.html#import-data",
    "title": "Take-home Exercise 01B",
    "section": "",
    "text": "To accomplish the task, Singapore Residents by Planning Area / Subzone, Single Year of Age and Sex, June 2024 dataset shared by Department of Statistics, Singapore (DOS) will be used and we wil load it as follows:\n\npop_data &lt;- read_csv(\"data/respopagesex2024.csv\", col_names = TRUE)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1B/Take-home_Ex01B.html#data-visualization",
    "href": "Take-home_Ex/Take-home_Ex_1B/Take-home_Ex01B.html#data-visualization",
    "title": "Take-home Exercise 01B",
    "section": "",
    "text": "Original Data Visualization:\n\npyramid_data &lt;- pop_data %&gt;%\n  group_by(Age, Sex) %&gt;%\n  summarise(Pop = sum(Pop), .groups = \"drop\") %&gt;%\n  mutate(Pop = ifelse(Sex == \"Males\", -Pop, Pop))\n\nggplot(pyramid_data, aes(x = Age, y = Pop, fill = Sex)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() +\n  scale_y_continuous(labels = abs) +\n  scale_fill_manual(values = c(\"Males\" = \"#102E50\", \"Females\" = \"#F7CFD8\")) + \n  scale_x_discrete(breaks = seq(0, 100, by = 10)) +\n  labs(title = \"Singapore Age Pyramid (2024)\",\n       x = \"Age\", y = \"Population\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nComments:\nThree good design principles:\n\nDifferent contrast colours are used to differentiate between Males and Females Resident count\nAppropriate use of chart (pyramid chart) instead of points to represent discrete values\nClear labeling for chart title, legend, x axis title and y axis title\n\nThree areas for further improvement:\n\nAxis Labeling and Scale Consistency\nConfusing x axis (starts from 0) and y axis (0 starts from the center) labeling. And, the distance between 0 to 10 to 20 on the y-axis is not consistent which signalling there is an error in the data preparation. The y-axis values ranges from 0 mark to 80 mark, whereas the dataset for Age ranges from 0 to 90+. There should be a 90 mark in the y-axis to represent the clearer and more accurate representation of the chart.\nGraphical Integrity: The top chart shows 2 wide bars after tapering off of the top pyramid which is not a true representation of the dataset. There should be a data cleaning performed before the visualization to change the data type for Age column from strings to integer and there is 1 value in the Age column: 90_and_Over that needs to be recoded to a numeric number. The lack of data preparation has led to the wrong representation of the data in this chart.\nGroup Ages into 5-Year Bins: The current age pyramid displays age in single-year intervals, resulting in a visually dense and harder-to-read chart. Binning the ages into 5-year groups (e.g., 0–4, 5–9, …, 85–89, 90+) would simplify the structure and highlight broader population trends more effectively. Additionally, including a vertical line to indicate the median age would provide a valuable reference point, making it easier to interpret the overall age distribution and identify demographic imbalance\n\nMakeover version of the Chart\nSome data preparation is needed: - to make the age group of interval 5 years from 0 to 90+ - to change the data type of Age from character to numeric\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\n\n# Data preparation\npyramid_data &lt;- pop_data %&gt;%\n  mutate(Age = ifelse(Age == \"90_and_Over\", \"91\", Age),\n         Age = as.numeric(Age)) %&gt;%\n  filter(!is.na(Age)) %&gt;%\n  mutate(AgeGroup = cut(Age,\n                        breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45,\n                                   50, 55, 60, 65, 70, 75, 80, 85, 90, Inf),\n                        right = TRUE,\n                        include.lowest = TRUE,\n                        labels = c(\"0–5\", \"6–10\", \"11–15\", \"16–20\", \"21–25\",\n                                   \"26–30\", \"31–35\", \"36–40\", \"41–45\", \"46–50\",\n                                   \"51–55\", \"56–60\", \"61–65\", \"66–70\", \"71–75\",\n                                   \"76–80\", \"81–85\", \"86–90\", \"90+\"))) %&gt;%\n  group_by(AgeGroup, Sex) %&gt;%\n  summarise(Pop = sum(Pop, na.rm = TRUE), .groups = \"drop\") %&gt;%\n  mutate(Pop = ifelse(Sex == \"Males\", -Pop, Pop),\n         Label = comma(abs(Pop), accuracy = 1),\n         Rank = dense_rank(desc(AgeGroup)))\n\nmedian_group &lt;- pyramid_data %&gt;%\n  group_by(AgeGroup) %&gt;%\n  summarise(TotalPop = sum(abs(Pop))) %&gt;%\n  mutate(CumSum = cumsum(TotalPop),\n         MedianFlag = CumSum &gt;= sum(TotalPop) / 2) %&gt;%\n  filter(MedianFlag) %&gt;%\n  slice(1) %&gt;%\n  pull(AgeGroup)\n\n# Plot\nggplot(pyramid_data, aes(x = AgeGroup, y = Pop, fill = Sex)) +\n  geom_bar(stat = \"identity\", width = 0.9) +\n  geom_text(aes(label = Label,\n              hjust = case_when(\n                AgeGroup %in% c(\"90+\", \"86–90\") & Sex == \"Males\" ~ 1.1,\n                AgeGroup %in% c(\"90+\", \"86–90\") & Sex == \"Females\" ~ -0.1,\n                Sex == \"Males\" ~ 0,  # centered inside left bar\n                Sex == \"Females\" ~ 1.5  # centered inside right bar\n              )),\n          size = 3, color = \"black\") +  # &lt;- Added the missing plus sign here\n  geom_vline(xintercept = 0, color = \"black\") +\n  coord_flip() +\n  scale_y_continuous(labels = NULL, breaks = NULL) +  # Remove x-axis tick values\n  scale_fill_manual(values = c(\"Males\" = \"#7EC8E3\", \"Females\" = \"#F7CFD8\")) +\n  labs(title = \"Singapore Population Age Pyramid (2024)\",\n       x = \"Age Group (Years)\", y = NULL, fill = \"Sex\") +\n  theme_minimal(base_size = 11) +\n  theme(plot.title = element_text(size = 14, face = \"bold\"),\n        axis.text.y = element_text(size = 9),\n        panel.grid.major.y = element_blank(),\n        legend.position = \"right\") +\n  annotate(\"text\", x = median_group, y = 0,\n           label = paste(\"Median:\", median_group),\n           vjust = -0.8, fontface = \"italic\", color = \"gray40\", size = 4)\n\n\n\n\n\n\n\nOriginal Visualization:\n\nlibrary(tidyverse)\n\n# Summarise total and elderly population by PA\ntop_areas &lt;- pop_data %&gt;%\n  group_by(PA) %&gt;%\n  summarise(\n    Total = sum(Pop),\n    Elderly = sum(Pop[Age &gt;= 65]),\n    .groups = \"drop\"\n  ) %&gt;%\n  \n  top_n(15, Total)  # or 20 if you prefer\n\n# Reshape into long format for grouped bars\nplot_data &lt;- top_areas %&gt;%\n  pivot_longer(cols = c(Total, Elderly),\n               names_to = \"Type\",\n               values_to = \"Population\") %&gt;%\n  mutate(\n    Type = recode(Type,\n                  \"Total\" = \"Total Population\",\n                  \"Elderly\" = \"Elderly (65+)\")\n  )\n# Reorder PA by Total Population (not elderly)\nplot_data &lt;- plot_data %&gt;%\n  left_join(top_areas %&gt;% select(PA, Total), by = \"PA\") %&gt;%\n  mutate(PA = fct_reorder(PA, Total, .desc = FALSE))  # use forcats::fct_reorder\n\nggplot(plot_data, aes(x = PA, y = Population, fill = Type)) +\n  geom_col(position = \"dodge\") +\n  geom_text(aes(label = scales::comma(Population)),\n            position = position_dodge(width = 0.9), hjust = -0.1, size = 3) +\n  scale_y_continuous(labels = scales::comma,\n                     expand = expansion(mult = c(0, 0.15))) +\n  scale_fill_manual(values = c(\"Total Population\" = \"#8E7DBE\", \"Elderly (65+)\" = \"#EFC000\")) +\n  coord_flip() +\n  labs(\n    title = \"Total vs Elderly Population in Top Planning Areas (2024)\",\n    x = \"Planning Area\",\n    y = \"Population\",\n    fill = \"\"\n  ) +\n  theme_classic()\n\n\n\n\n\n\n\n\nComments:\nThree good design principles:\n\nEffective use of contrast colours are used to differentiate between the total population and elderly population count by planning areas\nClear notation of the data values inside the chart\nClear labeling for legend, x axis and y axis title and mark.\n\nThree areas for further improvement\n\nThe chart currently includes both detailed bar annotations and x-axis tick marks, which introduces visual redundancy. When values are already clearly displayed inside or beside the bars, retaining dense tick marks on the x-axis adds clutter without enhancing interpretability. It is advisable to choose either to annotate values inside the chart or to rely on well-spaced x-axis tick marks—not both. Removing one will streamline the visual presentation and improve focus on the data.\nMisleading data due to insufficient data cleaning and preparation. The chart reflects inaccurate figures—e.g., Bedok’s elderly population is overstated as 70,130 instead of the correct 62,990—due to lack of data preparation. Proper data cleaning, including converting the Age column to numeric and recoding “90_and_Over” as 90, is essential to ensure data integrity and reliable insights.\nSorting and chart type The chart should be sorted by elderly population, not total population, to match its stated purpose. Using a stacked bar chart (rather than side-by-side horizontal barbars) would better show the elderly count in relation to the total population within each planning area.\n\nMakeover version of the Chart\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Data Preparation\npop_data &lt;- pop_data %&gt;%\n  mutate(\n    Age = str_trim(Age),\n    Age = case_when(\n      Age == \"90_and_Over\" ~ \"90\",\n      str_detect(Age, \"^[0-9]+$\") ~ Age,\n      TRUE ~ NA_character_\n    ),\n    Age = as.numeric(Age)\n  )\n\n\ntop_areas &lt;- pop_data %&gt;%\n  group_by(PA) %&gt;%\n  summarise(\n    Total = sum(Pop, na.rm = TRUE),\n    Elderly = sum(Pop[Age &gt;= 65], na.rm = TRUE),\n    .groups = \"drop\"\n  ) %&gt;%\n  slice_max(Elderly, n = 20)\n\n# Prepare data\nplot_data &lt;- top_areas %&gt;%\n  mutate(NonElderly = Total - Elderly) %&gt;%\n  select(PA, Elderly, NonElderly) %&gt;%\n  pivot_longer(cols = c(Elderly, NonElderly),\n               names_to = \"Group\",\n               values_to = \"Population\") %&gt;%\n  mutate(Group = recode(Group,\n                        \"Elderly\" = \"Elderly (65+)\",\n                        \"NonElderly\" = \"Non-Elderly\"),\n         Group = factor(Group, levels = c(\"Non-Elderly\", \"Elderly (65+)\"))) %&gt;%\n  left_join(top_areas %&gt;% select(PA, Elderly), by = \"PA\") %&gt;%\n  mutate(PA = fct_reorder(PA, Elderly, .desc = FALSE))  \n\n# Plot\nggplot(plot_data, aes(x = PA, y = Population, fill = Group)) +\n  geom_col(width = 0.9) +\n  scale_y_continuous(\n    breaks = seq(25000, 300000, by = 25000),\n    labels = function(x) x / 1000,  # Show in '000\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_fill_manual(values = c(\n    \"Non-Elderly\" = \"#A6D1E6\",\n    \"Elderly (65+)\" = \"#FFB347\"\n  )) +\n  coord_flip() +\n  labs(\n    title = \"Top 20 PA by Elderly Population Count (Age 65+)\",\n    x = \"Planning Area\",\n    y = \"Population (in '000)\",\n    fill = \"\"\n  ) +\n  theme_classic(base_size = 12) +\n  theme(legend.position = \"right\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Creating enlightening and truthful data visualizations involves focusing on accuracy, transparency, and the ability to effectively communicate insights. It’s about presenting data in a way that is both informative and aesthetically pleasing, ensuring the audience can grasp the information quickly and accurately.\n\n\n\nA local online media company that publishes daily content on digital platforms is planning to release an article on demographic structures and distribution of Singapore in 2024.\n\n\n\nAssuming the role of the graphical editor of the media company, we are tasked to prepare at most three data visualization for the article.\n\n\n\n\n\nWe load the following R packages using the pacman::p_load() function:\n\ntidyverse: R packages designed for data science\nggrepel: to provides geoms for ggplot2 to repel overlapping text labels\nggthemes: to use additional themes for ggplot2\npatchwork: to prepare composite figure created using ggplot2\nscales: to provide the internal scaling infrastructure used by ggplot2\nggpubr to create publication ready ggplot2 plots.\n\nThe code chunk below uses the p_load() function in the pacman package to check if the packages are installed in the computer.\n\npacman::p_load(tidyverse, ggrepel, patchwork, ggthemes, scales,\n               ggpubr) \n\n\n\n\nTo accomplish the task, Singapore Residents by Planning Area / Subzone, Single Year of Age and Sex, June 2024 dataset shared by Department of Statistics, Singapore (DOS) will be used and we wil load it as follows:\n\ndata &lt;- read_csv(\"data/respopagesex2024.csv\", col_names = TRUE)\n\n\n\n\n\n\nWe first take a look at the data. Using the code below, we can get the details of the dataset which contains 60,424 rows and 6 columns.\n\nglimpse(data)\n\nRows: 60,424\nColumns: 6\n$ PA   &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo K…\n$ SZ   &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Centre\", \"Ang Mo Kio T…\n$ Age  &lt;chr&gt; \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", \"4\", \"4\", \"5\", \"5\", \"6\", …\n$ Sex  &lt;chr&gt; \"Males\", \"Females\", \"Males\", \"Females\", \"Males\", \"Females\", \"Male…\n$ Pop  &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 30, 10, 20, 10, 20, 30, 30, 10, 3…\n$ Time &lt;dbl&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024,…\n\n\n\n\n\n\nWe notice that there is only one value in Time column (2024) which will not be used for further analysis, we will delete this column as per the code chunk below:\n\n\ndata &lt;- data %&gt;% select(-Time)\n\n\nWe will rename the column names in the dataset for clarity, as detailed provided by the Department of Statistics (DOS), as follows:\n\nPA → Planning Area\nSZ → Subzone\nPop → Resident Count\n\n\n\n\n\n\nSide Note:\n\n\n\nPlease note: according to the DOS accompanying documentation of this dataset, the population figures in the csv file have been rounded to the nearest 10, and as such, total counts may not sum exactly due to rounding adjustments.\n\n\n\ncolnames(data) &lt;- c(\"PlanningArea\", \"SubZone\", \"Age\", \"Sex\", \"ResidentCount\")\n\n\nNext, we observe that for the Age column, there is a value of : “90_and_over”. We will replace this value with “90” and change the data type from string/character to numeric and then create a new column to classify the age according to the age bracket in the interval of 5 years as per the standard age group published in DOS, with the following code:\n\n\ndata &lt;- data %&gt;%\n  mutate(\n    Age = str_to_lower(Age),\n    Age = ifelse(Age == \"90_and_over\", \"90\", Age),\n    Age = as.numeric(Age),\n    AgeGroup = cut(Age,\n                   breaks = c(0,4,9,14,19,24,29,34,39,44,49,54,59,64,69,74,79,84,89, Inf),\n                   labels = c(\"0–4\", \"5–9\", \"10–14\", \"15–19\", \"20–24\", \"25–29\",\n                              \"30–34\", \"35–39\", \"40–44\", \"45–49\", \"50–54\", \n                              \"55–59\", \"60–64\", \"65–69\", \"70–74\", \"75–79\", \n                              \"80–84\", \"85–89\", \"90+\"),\n                   right = TRUE, include.lowest = TRUE)\n  )\n\n\nFurther observation of the dataset, we discover there are multiple rows with “0” values in the “Pop”/“ResidentCount” column. We will remove these rows as per the code chunk below, and calculate the number of rows and total population before and after the deletion to ensure completeness with the following code:\n\n\ntotal_population_before &lt;- sum(data$ResidentCount, na.rm = TRUE)\ntotal_rows_before &lt;- nrow(data)\n\nzero_count &lt;- data %&gt;%\n  filter(ResidentCount == 0) %&gt;%\n  nrow()\n\ncat(\"Total population before cleaning:\", format(total_population_before, big.mark = \",\"), \"\\n\")\n\nTotal population before cleaning: 4,193,530 \n\ncat(\"Total rows before cleaning:\", total_rows_before, \"\\n\")\n\nTotal rows before cleaning: 60424 \n\ncat(\"Rows with 0 ResidentCount removed:\", zero_count, \"\\n\")\n\nRows with 0 ResidentCount removed: 23181 \n\ndata &lt;- data %&gt;%\n  filter(ResidentCount &gt; 0)\n\ntotal_population_after &lt;- sum(data$ResidentCount, na.rm = TRUE)\ntotal_rows_after &lt;- nrow(data)\n\ncat(\"Total population after cleaning:\", format(total_population_after, big.mark = \",\"), \"\\n\")\n\nTotal population after cleaning: 4,193,530 \n\ncat(\"Remaining rows:\", total_rows_after, \"\\n\")\n\nRemaining rows: 37243 \n\n\n\n\n\nNext, Using the duplicated function, we see that there are no duplicate entries in the data.\n\ndata[duplicated(data),]\n\n# A tibble: 0 × 6\n# ℹ 6 variables: PlanningArea &lt;chr&gt;, SubZone &lt;chr&gt;, Age &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   ResidentCount &lt;dbl&gt;, AgeGroup &lt;fct&gt;\n\n\n\n\n\nWe run the code below to check for any missing values, and there is none.\n\ncolSums(is.na(data))\n\n PlanningArea       SubZone           Age           Sex ResidentCount \n            0             0             0             0             0 \n     AgeGroup \n            0 \n\n\n\n\n\nWe run an overview of the final dataset again before proceeding to the visualization. Final dataset contains 37,243 rows and 7 columns:\n\nglimpse(data)\n\nRows: 37,243\nColumns: 6\n$ PlanningArea  &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", …\n$ SubZone       &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Centre\", \"Ang…\n$ Age           &lt;dbl&gt; 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9,…\n$ Sex           &lt;chr&gt; \"Males\", \"Females\", \"Males\", \"Females\", \"Males\", \"Female…\n$ ResidentCount &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 30, 10, 20, 10, 20, 30, …\n$ AgeGroup      &lt;fct&gt; 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 5–9, 5…\n\n\n\n\n\n\n\n\n\nInsights:\n\nThe population pyramid reveals a dominant working-age group between ages 30–44, forming the broadest segment of the chart, with largest age group for Female: from 35-39 age group: 166,150 and Males: from 30-34 age group with 155,630\nThe base is narrower, especially for those aged 0–14, which highlights the ongoing trend of declining birth rates.\nFemales significantly outnumber males from age 65 onwards, highlighting gender differences in life expectancy\nThe median age of 42 reinforces Singapore’s aging trend, with implications for healthcare and eldercare planning.\nThe median age of 42 underscores Singapore’s aging population, signaling increasing needs in healthcare, retirement, and eldercare.\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npyramid_data &lt;- data %&gt;%\n  group_by(AgeGroup, Sex) %&gt;%\n  summarise(ResidentCount = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    ResidentCountSigned = ifelse(Sex == \"Males\", -ResidentCount, ResidentCount),\n    fill_color = case_when(\n      Sex == \"Males\" ~ \"#4292c6\",\n      Sex == \"Females\" ~ \"#e377c2\",\n      TRUE ~ \"gray\"\n    ),\n    AgeGroup = factor(AgeGroup, levels = c(\"0–4\", \"5–9\", \"10–14\", \"15–19\", \"20–24\",\n                                           \"25–29\", \"30–34\", \"35–39\", \"40–44\", \"45–49\",\n                                           \"50–54\", \"55–59\", \"60–64\", \"65–69\", \"70–74\",\n                                           \"75–79\", \"80–84\", \"85–89\", \"90+\"))\n  )\n\nmedian_age &lt;- data %&gt;%\n  group_by(Age) %&gt;%\n  summarise(Total = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  arrange(Age) %&gt;%\n  mutate(cum_pop = cumsum(Total), prop = cum_pop / sum(Total)) %&gt;%\n  filter(prop &gt;= 0.5) %&gt;%\n  slice(1) %&gt;%\n  pull(Age)\n\nage_group_labels &lt;- levels(pyramid_data$AgeGroup)\nmedian_group_index &lt;- findInterval(median_age, seq(0, 100, by = 5))\nmedian_group &lt;- age_group_labels[median_group_index]\n\ntotal_males &lt;- pyramid_data %&gt;% filter(Sex == \"Males\") %&gt;% summarise(sum = sum(abs(ResidentCountSigned))) %&gt;% pull(sum)\ntotal_females &lt;- pyramid_data %&gt;% filter(Sex == \"Females\") %&gt;% summarise(sum = sum(ResidentCountSigned)) %&gt;% pull(sum)\n\nggplot(pyramid_data, aes(y = AgeGroup, x = ResidentCountSigned, fill = fill_color)) +\n  geom_col(width = 0.9) +\n  geom_text(aes(label = abs(ResidentCountSigned),\n                x = ifelse(ResidentCountSigned &lt; 0, ResidentCountSigned - 5000, ResidentCountSigned + 5000)),\n            hjust = ifelse(pyramid_data$ResidentCountSigned &lt; 0, 1, 0),\n            size = 3, color = \"black\") +\n  annotate(\"segment\",\n           x = -max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           xend = max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           y = median_group, yend = median_group,\n           linetype = \"dotted\", color = \"#A9A9A9\", linewidth = 0.9) +\n  annotate(\"text\",\n           x = max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           y = median_group,\n           label = paste0(\"Median: \", median_age),\n           hjust = 0, size = 2.8, color = \"black\", fontface = \"bold\") +\n  annotate(\"text\", y = \"0–4\",\n           x = -max(abs(pyramid_data$ResidentCountSigned)) * 0.95,\n           label = paste0(\"Males\\nTotal: \", format(total_males, big.mark = \",\")),\n           size = 2.6, color = \"#1E90FF\", fontface = \"bold\", hjust = 1) +\n  annotate(\"text\", y = \"0–4\",\n           x = max(abs(pyramid_data$ResidentCountSigned)) * 0.95,\n           label = paste0(\"Females\\nTotal: \", format(total_females, big.mark = \",\")),\n           size = 2.6, color = \"#c51b8a\", fontface = \"bold\", hjust = 0) +\n  scale_fill_identity() +\n  scale_x_continuous(labels = abs, expand = expansion(mult = c(0.12, 0.12))) +\n  labs(\n    title = \"Singapore’s Shifting Age Structure (June 2024)\",\n    subtitle = \"Middle-age Population Dominates; Youth Base Shrinking, Elderly Segment Rising\",\n    x = NULL,\n    y = \"Age Group (Years)\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 6)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 12)),\n    axis.text.y = element_text(size = 10),\n    axis.title.y = element_text(size = 11, face = \"bold\"),\n    axis.text.x = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank()\n  )\n\n\n\n\n\n\n\nInsights:\n\nThe top chart shows the proportion of elderly residents in the top 10 planning areas. Outram has the highest share, with 26.9% of its population are seniors, followed by Ang Mo Kio (24.3%) and Bukit Merah (23.4%). These established towns may benefit from enhanced elderly-supportive environments, such as barrier-free access, senior-oriented amenities, and close-proximity services.\nThe bottom chart presents the elderly resident count, with Bedok having the largest at 60,770, followed by Tampines (49,700) and Hougang (44,640). This is largely due to their larger area size and population base. These towns would benefit from service scaling, such as Active Ageing Centres (AACs), public transport connectivity, and healthcare access.\nWith Singapore’s elderly population projected to reach one in four residents (DOS, 2024), it is important to consider both distribution by proportion and resident count for effective planning.\nThis dual perspective supports the Ministry of Health’s 2023 Action Plan, which aims to double eldercare centres by 2025 and enhance community-based support (MOH, 2023).\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelderly_data &lt;- data %&gt;% filter(Age &gt;= 65)\n\ntotal_pop &lt;- data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Total_Pop = sum(ResidentCount, na.rm = TRUE))\n\nelderly_count &lt;- elderly_data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Elderly_Pop = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  arrange(desc(Elderly_Pop)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  mutate(PlanningArea = fct_reorder(PlanningArea, Elderly_Pop))\n\nelderly_prop &lt;- elderly_data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Elderly_Pop = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  left_join(total_pop, by = \"PlanningArea\") %&gt;%\n  mutate(Elderly_Proportion = Elderly_Pop / Total_Pop) %&gt;%\n  arrange(desc(Elderly_Proportion)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  mutate(PlanningArea = fct_reorder(PlanningArea, Elderly_Proportion))\n\n# Plot\np1 &lt;- ggplot(elderly_prop, aes(x = Elderly_Proportion, y = PlanningArea)) +\n  geom_col(fill = \"#4DAF4A\", width = 0.85) +\n  scale_x_continuous(\n    breaks = seq(0, 0.35, by = 0.05),\n    labels = percent_format(accuracy = 1),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Top 10 Planning Areas by Elderly Proportion (Age 65+)\",\n    x = \"Proportion of Elderly Residents\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title.x = element_text(size = 11),\n    panel.grid.major.x = element_line(color = \"grey90\"),\n    panel.grid.minor = element_blank()\n  )\n\n\np2 &lt;- ggplot(elderly_count, aes(x = Elderly_Pop, y = PlanningArea)) +\n  geom_col(fill = \"#4DAF4A\", width = 0.85) +\n  scale_x_continuous(\n    breaks = seq(0, 70000, by = 10000),\n    labels = comma_format(),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Top 10 Planning Areas by Elderly Resident Count (Age 65+)\",\n    x = \"Number of Elderly Residents\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title.x = element_text(size = 11),\n    panel.grid.major.x = element_line(color = \"grey90\"),\n    panel.grid.minor = element_blank()\n  )\n\np1 / p2\n\n\n\n\n\n\n\nInsights:\n\nTampines, Bedok, and Sengkang top the list of most populated PA with over 250,000 residents each.\nMillennials (age 28–43) are the largest group in most PA, while Gen X dominates in Bedok, a mature estate.\nYounger generations (Gen Alpha and Gen Z) are more concentrated in newer towns like Sengkang, Punggol, and Jurong West, aligned with recent BTO developments that attract young families.\nThe distribution reflects a balanced generational mix, highlighting Singapore’s multigenerational living pattern—with both aging residents and young households sharing town spaces.\nThese trends align with Singapore’s Smart Nation and HDB’s ‘Designing for Life’ vision: fostering harmonious, inclusive communities where families of all ages can live, age, and thrive together through well-integrated facilities, technology, and people-first urban design.\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata &lt;- data %&gt;%\n  mutate(Age = as.numeric(Age),\n         Generation = case_when(\n           Age &lt;= 9 ~ \"Gen Alpha (≤9)\",\n           Age &lt;= 27 ~ \"Gen Z (10–27)\",\n           Age &lt;= 43 ~ \"Millennials (28–43)\",\n           Age &lt;= 59 ~ \"Gen X (44–59)\",\n           Age &lt;= 77 ~ \"Baby Boomers (60–77)\",\n           TRUE ~ \"Silent Gen (78+)\"\n         ))\n\ngen_by_area &lt;- data %&gt;%\n  group_by(PlanningArea, Generation) %&gt;%\n  summarise(ResidentCount = sum(ResidentCount, na.rm = TRUE), .groups = \"drop\")\n\ntop10_areas &lt;- gen_by_area %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(TotalPop = sum(ResidentCount)) %&gt;%\n  arrange(desc(TotalPop)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  pull(PlanningArea)\n\ngen_top10 &lt;- gen_by_area %&gt;%\n  filter(PlanningArea %in% top10_areas) %&gt;%\n  mutate(\n    PlanningArea = fct_reorder(PlanningArea, ResidentCount, .fun = sum, .desc = TRUE),\n    Generation = factor(Generation, levels = c(\"Silent Gen (78+)\", \"Baby Boomers (60–77)\",\n                                               \"Gen X (44–59)\", \"Millennials (28–43)\",\n                                               \"Gen Z (10–27)\", \"Gen Alpha (≤9)\"))\n  )\n\ngen_colors &lt;- c(\n  \"Silent Gen (78+)\" = \"#c6dbef\",\n  \"Baby Boomers (60–77)\" = \"#6baed6\",\n  \"Gen X (44–59)\" = \"#b2df8a\",\n  \"Millennials (28–43)\" = \"#33a02c\",\n  \"Gen Z (10–27)\" = \"#fb9a99\",\n  \"Gen Alpha (≤9)\" = \"#e31a1c\"\n)\n\n#Plot\nggplot(gen_top10, aes(x = PlanningArea, y = ResidentCount, fill = Generation)) +\n  geom_col(width = 0.8, color = \"white\") +\n  scale_fill_manual(values = gen_colors) +\n  scale_y_continuous(\n    labels = comma,\n    breaks = seq(0, 300000, 50000),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Generational Composition of Top 10 Most Populated Planning Areas\",\n    subtitle = \"Younger generations dominate newer towns, while older cohorts concentrate in mature estates\",\n    x = \"Planning Area\",\n    y = \"Resident Count\",\n    fill = \"Generation\"\n  ) +\n  theme_clean(base_size = 12) +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 11, hjust = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\nSingapore’s demographic structure, based on June 2024 data, highlights a maturing society with a dominant working-age group and a median age of 42. The growing share of seniors and the narrowing base of younger age groups reflect the effects of population aging and low birth rates. Mature estates such as Outram have the highest proportion of elderly residents, while Bedok and Tampines house the largest absolute numbers. In contrast, newer towns like Sengkang and Punggol show higher concentrations of younger generations—particularly Gen Alpha and Gen Z—driven by recent BTO developments attracting young families. Millennials remain the largest generational group across most areas, reinforcing their role in shaping urban life. This evolving yet balanced generational landscape underscores the need for inclusive community planning that supports both young families and seniors—fostering intergenerational harmony and enabling families to live, age, and thrive together.\n\n\n\n\nDepartment of Statistics Singapore. (2024). Population Trends 2024.\nRetrieved from: https://www.singstat.gov.sg/publications/population/population-trends\nMinistry of Health Singapore. (2023). Action Plan for Successful Ageing.\nRetrieved from: https://www.moh.gov.sg/newsroom/launch-of-the-2023-action-plan-for-successful-ageing\nHousing & Development Board (HDB). (2021). Designing for Life: Community Planning and Design Guide.\nRetrieved from: https://www.hdb.gov.sg/cs/infoweb/designing-for-life\nSmart Nation and Digital Government Office. (2023). Smart Nation: Empowering Everyone Through Technology.\nRetrieved from: https://www.smartnation.gov.sg\nSingapore Department of Statistics. (n.d.). National Statistical Standards.\nRetrieved from: https://www.singstat.gov.sg/standards"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#overview",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#overview",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Creating enlightening and truthful data visualizations involves focusing on accuracy, transparency, and the ability to effectively communicate insights. It’s about presenting data in a way that is both informative and aesthetically pleasing, ensuring the audience can grasp the information quickly and accurately."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#setting-the-scene",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#setting-the-scene",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "A local online media company that publishes daily content on digital platforms is planning to release an article on demographic structures and distribution of Singapore in 2024."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#the-task",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#the-task",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Assuming the role of the graphical editor of the media company, we are tasked to prepare at most three data visualization for the article."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#getting-started",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#getting-started",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "We load the following R packages using the pacman::p_load() function:\n\ntidyverse: R packages designed for data science\nggrepel: to provides geoms for ggplot2 to repel overlapping text labels\nggthemes: to use additional themes for ggplot2\npatchwork: to prepare composite figure created using ggplot2\nscales: to provide the internal scaling infrastructure used by ggplot2\nggpubr to create publication ready ggplot2 plots.\n\nThe code chunk below uses the p_load() function in the pacman package to check if the packages are installed in the computer.\n\npacman::p_load(tidyverse, ggrepel, patchwork, ggthemes, scales,\n               ggpubr) \n\n\n\n\nTo accomplish the task, Singapore Residents by Planning Area / Subzone, Single Year of Age and Sex, June 2024 dataset shared by Department of Statistics, Singapore (DOS) will be used and we wil load it as follows:\n\ndata &lt;- read_csv(\"data/respopagesex2024.csv\", col_names = TRUE)\n\n\n\n\n\n\nWe first take a look at the data. Using the code below, we can get the details of the dataset which contains 60,424 rows and 6 columns.\n\nglimpse(data)\n\nRows: 60,424\nColumns: 6\n$ PA   &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo K…\n$ SZ   &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Centre\", \"Ang Mo Kio T…\n$ Age  &lt;chr&gt; \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", \"4\", \"4\", \"5\", \"5\", \"6\", …\n$ Sex  &lt;chr&gt; \"Males\", \"Females\", \"Males\", \"Females\", \"Males\", \"Females\", \"Male…\n$ Pop  &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 30, 10, 20, 10, 20, 30, 30, 10, 3…\n$ Time &lt;dbl&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024,…\n\n\n\n\n\n\nWe notice that there is only one value in Time column (2024) which will not be used for further analysis, we will delete this column as per the code chunk below:\n\n\ndata &lt;- data %&gt;% select(-Time)\n\n\nWe will rename the column names in the dataset for clarity, as detailed provided by the Department of Statistics (DOS), as follows:\n\nPA → Planning Area\nSZ → Subzone\nPop → Resident Count\n\n\n\n\n\n\nSide Note:\n\n\n\nPlease note: according to the DOS accompanying documentation of this dataset, the population figures in the csv file have been rounded to the nearest 10, and as such, total counts may not sum exactly due to rounding adjustments.\n\n\n\ncolnames(data) &lt;- c(\"PlanningArea\", \"SubZone\", \"Age\", \"Sex\", \"ResidentCount\")\n\n\nNext, we observe that for the Age column, there is a value of : “90_and_over”. We will replace this value with “90” and change the data type from string/character to numeric and then create a new column to classify the age according to the age bracket in the interval of 5 years as per the standard age group published in DOS, with the following code:\n\n\ndata &lt;- data %&gt;%\n  mutate(\n    Age = str_to_lower(Age),\n    Age = ifelse(Age == \"90_and_over\", \"90\", Age),\n    Age = as.numeric(Age),\n    AgeGroup = cut(Age,\n                   breaks = c(0,4,9,14,19,24,29,34,39,44,49,54,59,64,69,74,79,84,89, Inf),\n                   labels = c(\"0–4\", \"5–9\", \"10–14\", \"15–19\", \"20–24\", \"25–29\",\n                              \"30–34\", \"35–39\", \"40–44\", \"45–49\", \"50–54\", \n                              \"55–59\", \"60–64\", \"65–69\", \"70–74\", \"75–79\", \n                              \"80–84\", \"85–89\", \"90+\"),\n                   right = TRUE, include.lowest = TRUE)\n  )\n\n\nFurther observation of the dataset, we discover there are multiple rows with “0” values in the “Pop”/“ResidentCount” column. We will remove these rows as per the code chunk below, and calculate the number of rows and total population before and after the deletion to ensure completeness with the following code:\n\n\ntotal_population_before &lt;- sum(data$ResidentCount, na.rm = TRUE)\ntotal_rows_before &lt;- nrow(data)\n\nzero_count &lt;- data %&gt;%\n  filter(ResidentCount == 0) %&gt;%\n  nrow()\n\ncat(\"Total population before cleaning:\", format(total_population_before, big.mark = \",\"), \"\\n\")\n\nTotal population before cleaning: 4,193,530 \n\ncat(\"Total rows before cleaning:\", total_rows_before, \"\\n\")\n\nTotal rows before cleaning: 60424 \n\ncat(\"Rows with 0 ResidentCount removed:\", zero_count, \"\\n\")\n\nRows with 0 ResidentCount removed: 23181 \n\ndata &lt;- data %&gt;%\n  filter(ResidentCount &gt; 0)\n\ntotal_population_after &lt;- sum(data$ResidentCount, na.rm = TRUE)\ntotal_rows_after &lt;- nrow(data)\n\ncat(\"Total population after cleaning:\", format(total_population_after, big.mark = \",\"), \"\\n\")\n\nTotal population after cleaning: 4,193,530 \n\ncat(\"Remaining rows:\", total_rows_after, \"\\n\")\n\nRemaining rows: 37243 \n\n\n\n\n\nNext, Using the duplicated function, we see that there are no duplicate entries in the data.\n\ndata[duplicated(data),]\n\n# A tibble: 0 × 6\n# ℹ 6 variables: PlanningArea &lt;chr&gt;, SubZone &lt;chr&gt;, Age &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   ResidentCount &lt;dbl&gt;, AgeGroup &lt;fct&gt;\n\n\n\n\n\nWe run the code below to check for any missing values, and there is none.\n\ncolSums(is.na(data))\n\n PlanningArea       SubZone           Age           Sex ResidentCount \n            0             0             0             0             0 \n     AgeGroup \n            0 \n\n\n\n\n\nWe run an overview of the final dataset again before proceeding to the visualization. Final dataset contains 37,243 rows and 7 columns:\n\nglimpse(data)\n\nRows: 37,243\nColumns: 6\n$ PlanningArea  &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", …\n$ SubZone       &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Centre\", \"Ang…\n$ Age           &lt;dbl&gt; 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9,…\n$ Sex           &lt;chr&gt; \"Males\", \"Females\", \"Males\", \"Females\", \"Males\", \"Female…\n$ ResidentCount &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 30, 10, 20, 10, 20, 30, …\n$ AgeGroup      &lt;fct&gt; 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 5–9, 5…"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#data-visualization",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#data-visualization",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Insights:\n\nThe population pyramid reveals a dominant working-age group between ages 30–44, forming the broadest segment of the chart, with largest age group for Female: from 35-39 age group: 166,150 and Males: from 30-34 age group with 155,630\nThe base is narrower, especially for those aged 0–14, which highlights the ongoing trend of declining birth rates.\nFemales significantly outnumber males from age 65 onwards, highlighting gender differences in life expectancy\nThe median age of 42 reinforces Singapore’s aging trend, with implications for healthcare and eldercare planning.\nThe median age of 42 underscores Singapore’s aging population, signaling increasing needs in healthcare, retirement, and eldercare.\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npyramid_data &lt;- data %&gt;%\n  group_by(AgeGroup, Sex) %&gt;%\n  summarise(ResidentCount = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    ResidentCountSigned = ifelse(Sex == \"Males\", -ResidentCount, ResidentCount),\n    fill_color = case_when(\n      Sex == \"Males\" ~ \"#4292c6\",\n      Sex == \"Females\" ~ \"#e377c2\",\n      TRUE ~ \"gray\"\n    ),\n    AgeGroup = factor(AgeGroup, levels = c(\"0–4\", \"5–9\", \"10–14\", \"15–19\", \"20–24\",\n                                           \"25–29\", \"30–34\", \"35–39\", \"40–44\", \"45–49\",\n                                           \"50–54\", \"55–59\", \"60–64\", \"65–69\", \"70–74\",\n                                           \"75–79\", \"80–84\", \"85–89\", \"90+\"))\n  )\n\nmedian_age &lt;- data %&gt;%\n  group_by(Age) %&gt;%\n  summarise(Total = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  arrange(Age) %&gt;%\n  mutate(cum_pop = cumsum(Total), prop = cum_pop / sum(Total)) %&gt;%\n  filter(prop &gt;= 0.5) %&gt;%\n  slice(1) %&gt;%\n  pull(Age)\n\nage_group_labels &lt;- levels(pyramid_data$AgeGroup)\nmedian_group_index &lt;- findInterval(median_age, seq(0, 100, by = 5))\nmedian_group &lt;- age_group_labels[median_group_index]\n\ntotal_males &lt;- pyramid_data %&gt;% filter(Sex == \"Males\") %&gt;% summarise(sum = sum(abs(ResidentCountSigned))) %&gt;% pull(sum)\ntotal_females &lt;- pyramid_data %&gt;% filter(Sex == \"Females\") %&gt;% summarise(sum = sum(ResidentCountSigned)) %&gt;% pull(sum)\n\nggplot(pyramid_data, aes(y = AgeGroup, x = ResidentCountSigned, fill = fill_color)) +\n  geom_col(width = 0.9) +\n  geom_text(aes(label = abs(ResidentCountSigned),\n                x = ifelse(ResidentCountSigned &lt; 0, ResidentCountSigned - 5000, ResidentCountSigned + 5000)),\n            hjust = ifelse(pyramid_data$ResidentCountSigned &lt; 0, 1, 0),\n            size = 3, color = \"black\") +\n  annotate(\"segment\",\n           x = -max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           xend = max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           y = median_group, yend = median_group,\n           linetype = \"dotted\", color = \"#A9A9A9\", linewidth = 0.9) +\n  annotate(\"text\",\n           x = max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           y = median_group,\n           label = paste0(\"Median: \", median_age),\n           hjust = 0, size = 2.8, color = \"black\", fontface = \"bold\") +\n  annotate(\"text\", y = \"0–4\",\n           x = -max(abs(pyramid_data$ResidentCountSigned)) * 0.95,\n           label = paste0(\"Males\\nTotal: \", format(total_males, big.mark = \",\")),\n           size = 2.6, color = \"#1E90FF\", fontface = \"bold\", hjust = 1) +\n  annotate(\"text\", y = \"0–4\",\n           x = max(abs(pyramid_data$ResidentCountSigned)) * 0.95,\n           label = paste0(\"Females\\nTotal: \", format(total_females, big.mark = \",\")),\n           size = 2.6, color = \"#c51b8a\", fontface = \"bold\", hjust = 0) +\n  scale_fill_identity() +\n  scale_x_continuous(labels = abs, expand = expansion(mult = c(0.12, 0.12))) +\n  labs(\n    title = \"Singapore’s Shifting Age Structure (June 2024)\",\n    subtitle = \"Middle-age Population Dominates; Youth Base Shrinking, Elderly Segment Rising\",\n    x = NULL,\n    y = \"Age Group (Years)\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 6)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 12)),\n    axis.text.y = element_text(size = 10),\n    axis.title.y = element_text(size = 11, face = \"bold\"),\n    axis.text.x = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank()\n  )\n\n\n\n\n\n\n\nInsights:\n\nThe top chart shows the proportion of elderly residents in the top 10 planning areas. Outram has the highest share, with 26.9% of its population are seniors, followed by Ang Mo Kio (24.3%) and Bukit Merah (23.4%). These established towns may benefit from enhanced elderly-supportive environments, such as barrier-free access, senior-oriented amenities, and close-proximity services.\nThe bottom chart presents the elderly resident count, with Bedok having the largest at 60,770, followed by Tampines (49,700) and Hougang (44,640). This is largely due to their larger area size and population base. These towns would benefit from service scaling, such as Active Ageing Centres (AACs), public transport connectivity, and healthcare access.\nWith Singapore’s elderly population projected to reach one in four residents (DOS, 2024), it is important to consider both distribution by proportion and resident count for effective planning.\nThis dual perspective supports the Ministry of Health’s 2023 Action Plan, which aims to double eldercare centres by 2025 and enhance community-based support (MOH, 2023).\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelderly_data &lt;- data %&gt;% filter(Age &gt;= 65)\n\ntotal_pop &lt;- data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Total_Pop = sum(ResidentCount, na.rm = TRUE))\n\nelderly_count &lt;- elderly_data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Elderly_Pop = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  arrange(desc(Elderly_Pop)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  mutate(PlanningArea = fct_reorder(PlanningArea, Elderly_Pop))\n\nelderly_prop &lt;- elderly_data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Elderly_Pop = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  left_join(total_pop, by = \"PlanningArea\") %&gt;%\n  mutate(Elderly_Proportion = Elderly_Pop / Total_Pop) %&gt;%\n  arrange(desc(Elderly_Proportion)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  mutate(PlanningArea = fct_reorder(PlanningArea, Elderly_Proportion))\n\n# Plot\np1 &lt;- ggplot(elderly_prop, aes(x = Elderly_Proportion, y = PlanningArea)) +\n  geom_col(fill = \"#4DAF4A\", width = 0.85) +\n  scale_x_continuous(\n    breaks = seq(0, 0.35, by = 0.05),\n    labels = percent_format(accuracy = 1),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Top 10 Planning Areas by Elderly Proportion (Age 65+)\",\n    x = \"Proportion of Elderly Residents\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title.x = element_text(size = 11),\n    panel.grid.major.x = element_line(color = \"grey90\"),\n    panel.grid.minor = element_blank()\n  )\n\n\np2 &lt;- ggplot(elderly_count, aes(x = Elderly_Pop, y = PlanningArea)) +\n  geom_col(fill = \"#4DAF4A\", width = 0.85) +\n  scale_x_continuous(\n    breaks = seq(0, 70000, by = 10000),\n    labels = comma_format(),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Top 10 Planning Areas by Elderly Resident Count (Age 65+)\",\n    x = \"Number of Elderly Residents\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title.x = element_text(size = 11),\n    panel.grid.major.x = element_line(color = \"grey90\"),\n    panel.grid.minor = element_blank()\n  )\n\np1 / p2\n\n\n\n\n\n\n\nInsights:\n\nTampines, Bedok, and Sengkang top the list of most populated PA with over 250,000 residents each.\nMillennials (age 28–43) are the largest group in most PA, while Gen X dominates in Bedok, a mature estate.\nYounger generations (Gen Alpha and Gen Z) are more concentrated in newer towns like Sengkang, Punggol, and Jurong West, aligned with recent BTO developments that attract young families.\nThe distribution reflects a balanced generational mix, highlighting Singapore’s multigenerational living pattern—with both aging residents and young households sharing town spaces.\nThese trends align with Singapore’s Smart Nation and HDB’s ‘Designing for Life’ vision: fostering harmonious, inclusive communities where families of all ages can live, age, and thrive together through well-integrated facilities, technology, and people-first urban design.\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata &lt;- data %&gt;%\n  mutate(Age = as.numeric(Age),\n         Generation = case_when(\n           Age &lt;= 9 ~ \"Gen Alpha (≤9)\",\n           Age &lt;= 27 ~ \"Gen Z (10–27)\",\n           Age &lt;= 43 ~ \"Millennials (28–43)\",\n           Age &lt;= 59 ~ \"Gen X (44–59)\",\n           Age &lt;= 77 ~ \"Baby Boomers (60–77)\",\n           TRUE ~ \"Silent Gen (78+)\"\n         ))\n\ngen_by_area &lt;- data %&gt;%\n  group_by(PlanningArea, Generation) %&gt;%\n  summarise(ResidentCount = sum(ResidentCount, na.rm = TRUE), .groups = \"drop\")\n\ntop10_areas &lt;- gen_by_area %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(TotalPop = sum(ResidentCount)) %&gt;%\n  arrange(desc(TotalPop)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  pull(PlanningArea)\n\ngen_top10 &lt;- gen_by_area %&gt;%\n  filter(PlanningArea %in% top10_areas) %&gt;%\n  mutate(\n    PlanningArea = fct_reorder(PlanningArea, ResidentCount, .fun = sum, .desc = TRUE),\n    Generation = factor(Generation, levels = c(\"Silent Gen (78+)\", \"Baby Boomers (60–77)\",\n                                               \"Gen X (44–59)\", \"Millennials (28–43)\",\n                                               \"Gen Z (10–27)\", \"Gen Alpha (≤9)\"))\n  )\n\ngen_colors &lt;- c(\n  \"Silent Gen (78+)\" = \"#c6dbef\",\n  \"Baby Boomers (60–77)\" = \"#6baed6\",\n  \"Gen X (44–59)\" = \"#b2df8a\",\n  \"Millennials (28–43)\" = \"#33a02c\",\n  \"Gen Z (10–27)\" = \"#fb9a99\",\n  \"Gen Alpha (≤9)\" = \"#e31a1c\"\n)\n\n#Plot\nggplot(gen_top10, aes(x = PlanningArea, y = ResidentCount, fill = Generation)) +\n  geom_col(width = 0.8, color = \"white\") +\n  scale_fill_manual(values = gen_colors) +\n  scale_y_continuous(\n    labels = comma,\n    breaks = seq(0, 300000, 50000),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Generational Composition of Top 10 Most Populated Planning Areas\",\n    subtitle = \"Younger generations dominate newer towns, while older cohorts concentrate in mature estates\",\n    x = \"Planning Area\",\n    y = \"Resident Count\",\n    fill = \"Generation\"\n  ) +\n  theme_clean(base_size = 12) +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 11, hjust = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    legend.position = \"right\"\n  )"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#summary",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#summary",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Singapore’s demographic structure, based on June 2024 data, highlights a maturing society with a dominant working-age group and a median age of 42. The growing share of seniors and the narrowing base of younger age groups reflect the effects of population aging and low birth rates. Mature estates such as Outram have the highest proportion of elderly residents, while Bedok and Tampines house the largest absolute numbers. In contrast, newer towns like Sengkang and Punggol show higher concentrations of younger generations—particularly Gen Alpha and Gen Z—driven by recent BTO developments attracting young families. Millennials remain the largest generational group across most areas, reinforcing their role in shaping urban life. This evolving yet balanced generational landscape underscores the need for inclusive community planning that supports both young families and seniors—fostering intergenerational harmony and enabling families to live, age, and thrive together."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#references",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-home_Ex01.html#references",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Department of Statistics Singapore. (2024). Population Trends 2024.\nRetrieved from: https://www.singstat.gov.sg/publications/population/population-trends\nMinistry of Health Singapore. (2023). Action Plan for Successful Ageing.\nRetrieved from: https://www.moh.gov.sg/newsroom/launch-of-the-2023-action-plan-for-successful-ageing\nHousing & Development Board (HDB). (2021). Designing for Life: Community Planning and Design Guide.\nRetrieved from: https://www.hdb.gov.sg/cs/infoweb/designing-for-life\nSmart Nation and Digital Government Office. (2023). Smart Nation: Empowering Everyone Through Technology.\nRetrieved from: https://www.smartnation.gov.sg\nSingapore Department of Statistics. (n.d.). National Statistical Standards.\nRetrieved from: https://www.singstat.gov.sg/standards"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html",
    "title": "Hands-on Exercise 05",
    "section": "",
    "text": "In this hands-on exercise, we will learn how to model, analyse and visualise network data using R,\nto be able to:\n\ncreate graph object data frames, manipulate them using appropriate functions of dplyr, lubridate, and tidygraph,\nbuild network graph visualisation using appropriate functions of ggraph,\ncompute network geometrics using tidygraph,\nbuild advanced graph visualisation by incorporating the network geometrics, and\nbuild interactive network visualisation using visNetwork package.\n\n\n\n\n\n\nIn this hands-on exercise, four network data modelling and visualisation packages will be installed and launched. They are igraph, tidygraph, ggraph and visNetwork. Beside these four packages, tidyverse and lubridate, an R package specially designed to handle and wrangling time data will be installed and launched too.\nThe code chunk:\n\n\nShow the code\n\n\npacman::p_load(igraph, tidygraph, ggraph, \n               visNetwork, lubridate, clock,\n               tidyverse, graphlayouts, \n               concaveman, ggforce)\n\n\n\n\n\n\nThe data sets used in this hands-on exercise is from an oil exploration and extraction company. There are two data sets. One contains the nodes data and the other contains the edges (also know as link) data.\n\n\n\nGAStech-email_edges.csv which consists of two weeks of 9063 emails correspondances between 55 employees.\n\n\n\n\n\n\nGAStech_email_nodes.csv which consist of the names, department and title of the 55 employees.\n\n\n\n\n\nIn this step, we will import GAStech_email_node.csv and GAStech_email_edges-v2.csv into RStudio environment by using read_csv() of readr package.\n\n\nShow the code\n\n\nGAStech_nodes &lt;- read_csv(\"data/GAStech_email_node.csv\")\nGAStech_edges &lt;- read_csv(\"data/GAStech_email_edge-v2.csv\")\n\n\n\n\n\nNext, we will examine the structure of the data frame using glimpse() of dplyr.\n\n\nShow the code\n\n\nglimpse(GAStech_edges)\n\nRows: 9,063\nColumns: 8\n$ source      &lt;dbl&gt; 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 26, 26, 26…\n$ target      &lt;dbl&gt; 41, 40, 51, 52, 53, 45, 44, 46, 48, 49, 47, 54, 27, 28, 29…\n$ SentDate    &lt;chr&gt; \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\"…\n$ SentTime    &lt;time&gt; 08:39:00, 08:39:00, 08:58:00, 08:58:00, 08:58:00, 08:58:0…\n$ Subject     &lt;chr&gt; \"GT-SeismicProcessorPro Bug Report\", \"GT-SeismicProcessorP…\n$ MainSubject &lt;chr&gt; \"Work related\", \"Work related\", \"Work related\", \"Work rela…\n$ sourceLabel &lt;chr&gt; \"Sven.Flecha\", \"Sven.Flecha\", \"Kanon.Herrero\", \"Kanon.Herr…\n$ targetLabel &lt;chr&gt; \"Isak.Baza\", \"Lucas.Alcazar\", \"Felix.Resumir\", \"Hideki.Coc…\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe output report of GAStech_edges above reveals that the SentDate is treated as “Character” data type instead of date data type. This is an error! Before we continue, it is important for us to change the data type of SentDate field back to “Date”” data type.\n\n\n\n\n\nThe code chunk below will be used to perform the changes.\n\n\nShow the code\n\n\nGAStech_edges &lt;- GAStech_edges %&gt;%\n  mutate(SendDate = dmy(SentDate)) %&gt;%\n  mutate(Weekday = wday(SentDate,\n                        label = TRUE,\n                        abbr = FALSE))\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nboth dmy() and wday() are functions of lubridate package. lubridate is an R package that makes it easier to work with dates and times.\ndmy() transforms the SentDate to Date data type.\nwday() returns the day of the week as a decimal number or an ordered factor if label is TRUE. The argument abbr is FALSE keep the daya spells in full, i.e. Monday. The function will create a new column in the data.frame i.e. Weekday and the output of wday() will save in this newly created field.\nthe values in the Weekday field are in ordinal scale.\n\n\n\n\n\n\nTable below shows the data structure of the reformatted GAStech_edges data frame\n\nglimpse(GAStech_edges)\n\nRows: 9,063\nColumns: 10\n$ source      &lt;dbl&gt; 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 26, 26, 26…\n$ target      &lt;dbl&gt; 41, 40, 51, 52, 53, 45, 44, 46, 48, 49, 47, 54, 27, 28, 29…\n$ SentDate    &lt;chr&gt; \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\"…\n$ SentTime    &lt;time&gt; 08:39:00, 08:39:00, 08:58:00, 08:58:00, 08:58:00, 08:58:0…\n$ Subject     &lt;chr&gt; \"GT-SeismicProcessorPro Bug Report\", \"GT-SeismicProcessorP…\n$ MainSubject &lt;chr&gt; \"Work related\", \"Work related\", \"Work related\", \"Work rela…\n$ sourceLabel &lt;chr&gt; \"Sven.Flecha\", \"Sven.Flecha\", \"Kanon.Herrero\", \"Kanon.Herr…\n$ targetLabel &lt;chr&gt; \"Isak.Baza\", \"Lucas.Alcazar\", \"Felix.Resumir\", \"Hideki.Coc…\n$ SendDate    &lt;date&gt; 2014-01-06, 2014-01-06, 2014-01-06, 2014-01-06, 2014-01-0…\n$ Weekday     &lt;ord&gt; Friday, Friday, Friday, Friday, Friday, Friday, Friday, Fr…\n\n\n\n\n\nA close examination of GAStech_edges data.frame reveals that it consists of individual e-mail flow records. This is not very useful for visualisation.\nIn view of this, we will aggregate the individual by date, senders, receivers, main subject and day of the week.\nThe code chunk:\n\n\nShow the code\n\n\nGAStech_edges_aggregated &lt;- GAStech_edges %&gt;%\n  filter(MainSubject == \"Work related\") %&gt;%\n  group_by(source, target, Weekday) %&gt;%\n    summarise(Weight = n()) %&gt;%\n  filter(source!=target) %&gt;%\n  filter(Weight &gt; 1) %&gt;%\n  ungroup()\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nfour functions from dplyr package are used. They are: filter(), group(), summarise(), and ungroup().\nThe output data.frame is called GAStech_edges_aggregated.\nA new field called Weight has been added in GAStech_edges_aggregated.\n\n\n\n\n\n\nTable below shows the data structure of the reformatted GAStech_edges_aggregated data frame\n\nglimpse(GAStech_edges_aggregated)\n\nRows: 1,372\nColumns: 4\n$ source  &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ target  &lt;dbl&gt; 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6,…\n$ Weekday &lt;ord&gt; Sunday, Monday, Tuesday, Wednesday, Friday, Sunday, Monday, Tu…\n$ Weight  &lt;int&gt; 5, 2, 3, 4, 6, 5, 2, 3, 4, 6, 5, 2, 3, 4, 6, 5, 2, 3, 4, 6, 5,…\n\n\n\n\n\n\nIn this section, you will learn how to create a graph data model by using tidygraph package. It provides a tidy API for graph/network manipulation. While network data itself is not tidy, it can be envisioned as two tidy tables, one for node data and one for edge data. tidygraph provides a way to switch between the two tables and provides dplyr verbs for manipulating them. Furthermore it provides access to a lot of graph algorithms with return values that facilitate their use in a tidy workflow.\nBefore getting started, you are advised to read these two articles:\n\nIntroducing tidygraph\ntidygraph 1.1 - A tidy hope\n\n\n\nTwo functions of tidygraph package can be used to create network objects, they are:\n\ntbl_graph() creates a tbl_graph network object from nodes and edges data.\nas_tbl_graph() converts network data and objects to a tbl_graph network. Below are network data and objects supported by as_tbl_graph()\n\na node data.frame and an edge data.frame,\ndata.frame, list, matrix from base,\nigraph from igraph,\nnetwork from network,\ndendrogram and hclust from stats,\nNode from data.tree,\nphylo and evonet from ape, and\ngraphNEL, graphAM, graphBAM from graph (in Bioconductor).\n\n\n\n\n\n\nactivate() verb from tidygraph serves as a switch between tibbles for nodes and edges. All dplyr verbs applied to tbl_graph object are applied to the active tibble.\n\n\n\nIn the above the .N() function is used to gain access to the node data while manipulating the edge data. Similarly .E() will give you the edge data and .G() will give you the tbl_graph object itself.\n\n\n\n\nIn this section, we will use tbl_graph() of tinygraph package to build an tidygraph’s network graph data.frame.\nBefore typing the codes, it is recommended to review to reference guide of tbl_graph()\n\n\nShow the code\n\n\nGAStech_graph &lt;- tbl_graph(nodes = GAStech_nodes,\n                           edges = GAStech_edges_aggregated, \n                           directed = TRUE)\n\n\n\n\n\n\n\nShow the code\n\n\nGAStech_graph\n\n# A tbl_graph: 54 nodes and 1372 edges\n#\n# A directed multigraph with 1 component\n#\n# Node Data: 54 × 4 (active)\n      id label               Department     Title                               \n   &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt;          &lt;chr&gt;                               \n 1     1 Mat.Bramar          Administration Assistant to CEO                    \n 2     2 Anda.Ribera         Administration Assistant to CFO                    \n 3     3 Rachel.Pantanal     Administration Assistant to CIO                    \n 4     4 Linda.Lagos         Administration Assistant to COO                    \n 5     5 Ruscella.Mies.Haber Administration Assistant to Engineering Group Mana…\n 6     6 Carla.Forluniau     Administration Assistant to IT Group Manager       \n 7     7 Cornelia.Lais       Administration Assistant to Security Group Manager \n 8    44 Kanon.Herrero       Security       Badging Office                      \n 9    45 Varja.Lagos         Security       Badging Office                      \n10    46 Stenig.Fusil        Security       Building Control                    \n# ℹ 44 more rows\n#\n# Edge Data: 1,372 × 4\n   from    to Weekday Weight\n  &lt;int&gt; &lt;int&gt; &lt;ord&gt;    &lt;int&gt;\n1     1     2 Sunday       5\n2     1     2 Monday       2\n3     1     2 Tuesday      3\n# ℹ 1,369 more rows\n\n\n\n\n\n\n\nThe output above reveals that GAStech_graph is a tbl_graph object with 54 nodes and 4541 edges.\nThe command also prints the first six rows of “Node Data” and the first three of “Edge Data”.\nIt states that the Node Data is active. The notion of an active tibble within a tbl_graph object makes it possible to manipulate the data in one tibble at a time.\n\n\n\n\nThe nodes tibble data frame is activated by default, but you can change which tibble data frame is active with the activate() function. Thus, if we wanted to rearrange the rows in the edges tibble to list those with the highest “weight” first, we could use activate() and then arrange().\nFor example,\n\n\nShow the code\n\n\nGAStech_graph %&gt;%\n  activate(edges) %&gt;%\n  arrange(desc(Weight))\n\n# A tbl_graph: 54 nodes and 1372 edges\n#\n# A directed multigraph with 1 component\n#\n# Edge Data: 1,372 × 4 (active)\n    from    to Weekday   Weight\n   &lt;int&gt; &lt;int&gt; &lt;ord&gt;      &lt;int&gt;\n 1    40    41 Saturday      13\n 2    41    43 Monday        11\n 3    35    31 Tuesday       10\n 4    40    41 Monday        10\n 5    40    43 Monday        10\n 6    36    32 Sunday         9\n 7    40    43 Saturday       9\n 8    41    40 Monday         9\n 9    19    15 Wednesday      8\n10    35    38 Tuesday        8\n# ℹ 1,362 more rows\n#\n# Node Data: 54 × 4\n     id label           Department     Title           \n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;          &lt;chr&gt;           \n1     1 Mat.Bramar      Administration Assistant to CEO\n2     2 Anda.Ribera     Administration Assistant to CFO\n3     3 Rachel.Pantanal Administration Assistant to CIO\n# ℹ 51 more rows\n\n\n\nVisit the reference guide of activate() to find out more about the function.\n\n\n\n\nggraph is an extension of ggplot2, making it easier to carry over basic ggplot skills to the design of network graphs.\nAs in all network graph, there are three main aspects to a ggraph’s network graph, they are:\n\nnodes,\nedges and\nlayouts.\n\nFor a comprehensive discussion of each of this aspect of graph, please refer to their respective vignettes provided.\n\n\nThe code chunk below uses ggraph(), geom-edge_link() and geom_node_point() to plot a network graph by using GAStech_graph. Before your get started, it is advisable to read their respective reference guide at least once.\n\n\nShow the code\n\n\nggraph(GAStech_graph) +\n  geom_edge_link() +\n  geom_node_point()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nThe basic plotting function is ggraph(), which takes the data to be used for the graph and the type of layout desired. Both of the arguments for ggraph() are built around igraph. Therefore, ggraph() can use either an igraph object or a tbl_graph object.\n\n\n\n\n\n\nIn this section, you will use theme_graph() to remove the x and y axes. Before your get started, it is advisable to read it’s reference guide at least once.\n\n\nShow the code\n\n\ng &lt;- ggraph(GAStech_graph) + \n  geom_edge_link(aes()) +\n  geom_node_point(aes())\n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nggraph introduces a special ggplot theme that provides better defaults for network graphs than the normal ggplot defaults. theme_graph(), besides removing axes, grids, and border, changes the font to Arial Narrow (this can be overridden).\nThe ggraph theme can be set for a series of plots with the set_graph_style() command run before the graphs are plotted or by using theme_graph() in the individual plots.\n\n\n\n\n\n\nFurthermore, theme_graph() makes it easy to change the coloring of the plot.\n\n\nShow the code\n\n\ng &lt;- ggraph(GAStech_graph) + \n  geom_edge_link(aes(colour = 'grey50')) +\n  geom_node_point(aes(colour = 'grey40'))\n\ng + theme_graph(background = 'grey10',\n                text_colour = 'white')\n\n\n\n\n\n\n\n\n\n\n\n\nggraph support many layout for standard used, they are: star, circle, nicely (default), dh, gem, graphopt, grid, mds, spahere, randomly, fr, kk, drl and lgl. Figures below and on the right show layouts supported by ggraph().\n\n\n\n\nThe code chunks below will be used to plot the network graph using Fruchterman and Reingold layout.\n\n\nShow the code\n\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"fr\") +\n  geom_edge_link(aes()) +\n  geom_node_point(aes())\n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\nThing to learn from the code chunk above:\n\nlayout argument is used to define the layout to be used.\n\n\n\n\nIn this section, we will colour each node by referring to their respective departments.\n\n\nShow the code\n\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes()) +\n  geom_node_point(aes(colour = Department, \n                      size = 3))\n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunks above:\n\ngeom_node_point is equivalent in functionality to geo_point of ggplot2. It allows for simple plotting of nodes in different shapes, colours and sizes. In the codes chnuks above colour and size are used.\n\n\n\n\nIn the code chunk below, the thickness of the edges will be mapped with the Weight variable.\n\n\nShow the code\n\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") +\n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 3)\n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunks above:\n\ngeom_edge_link draws edges in the simplest way - as straight lines between the start and end nodes. But, it can do more that that. In the example above, argument width is used to map the width of the line in proportional to the Weight attribute and argument alpha is used to introduce opacity on the line.\n\n\n\n\n\nAnother very useful feature of ggraph is faceting. In visualising network data, this technique can be used to reduce edge over-plotting in a very meaning way by spreading nodes and edges out based on their attributes. In this section, we will learn how to use faceting technique to visualise network data.\nThere are three functions in ggraph to implement faceting, they are:\n\nfacet_nodes() whereby edges are only draw in a panel if both terminal nodes are present here,\nfacet_edges() whereby nodes are always drawn in al panels even if the node data contains an attribute named the same as the one used for the edge facetting, and\nfacet_graph() faceting on two variables simultaneously.\n\n\n\nIn the code chunk below, facet_edges() is used. Before getting started, it is advisable for us to read it’s reference guide at least once.\n\n\nShow the code\n\n\nset_graph_style()\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2)\n\ng + facet_edges(~Weekday)\n\n\n\n\n\n\n\n\n\n\n\n\nThe code chunk below uses theme() to change the position of the legend.\n\n\nShow the code\n\n\nset_graph_style()\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2) +\n  theme(legend.position = 'bottom')\n  \ng + facet_edges(~Weekday)\n\n\n\n\n\n\n\n\n\n\n\n\nThe code chunk below adds frame to each graph.\n\n\nShow the code\n\n\nset_graph_style() \n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2)\n  \ng + facet_edges(~Weekday) +\n  th_foreground(foreground = \"grey80\",  \n                border = TRUE) +\n  theme(legend.position = 'bottom')\n\n\n\n\n\n\n\n\n\n\n\n\nIn the code chunkc below, facet_nodes() is used. Before getting started, it is advisable for you to read it’s reference guide at least once.\n\n\nShow the code\n\n\nset_graph_style()\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2)\n  \ng + facet_nodes(~Department)+\n  th_foreground(foreground = \"grey80\",  \n                border = TRUE) +\n  theme(legend.position = 'bottom')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCentrality measures are a collection of statistical indices use to describe the relative important of the actors are to a network. There are four well-known centrality measures, namely: degree, betweenness, closeness and eigenvector. It is beyond the scope of this hands-on exercise to cover the principles and mathematics of these measure here. Students are encouraged to refer to Chapter 7: Actor Prominence of A User’s Guide to Network Analysis in R to gain better understanding of theses network measures.\n\n\nShow the code\n\n\ng &lt;- GAStech_graph %&gt;%\n  mutate(betweenness_centrality = centrality_betweenness()) %&gt;%\n  ggraph(layout = \"fr\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department,\n            size=betweenness_centrality))\ng + theme_graph()\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\nmutate() of dplyr is used to perform the computation.\nthe algorithm used, on the other hand, is the centrality_betweenness() of tidygraph.\n\n\n\n\nIt is important to note that from ggraph v2.0 onward tidygraph algorithms such as centrality measures can be accessed directly in ggraph calls. This means that it is no longer necessary to precompute and store derived node and edge centrality measures on the graph in order to use them in a plot.\n\n\nShow the code\n\n\ng &lt;- GAStech_graph %&gt;%\n  ggraph(layout = \"fr\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department, \n                      size = centrality_betweenness()))\ng + theme_graph()\n\n\n\n\n\n\n\n\n\n\n\n\ntidygraph package inherits many of the community detection algorithms imbedded into igraph and makes them available to us, including Edge-betweenness (group_edge_betweenness), Leading eigenvector (group_leading_eigen), Fast-greedy (group_fast_greedy), Louvain (group_louvain), Walktrap (group_walktrap), Label propagation (group_label_prop), InfoMAP (group_infomap), Spinglass (group_spinglass), and Optimal (group_optimal). Some community algorithms are designed to take into account direction or weight, while others ignore it. Use this link to find out more about community detection functions provided by tidygraph,\nIn the code chunk below group_edge_betweenness() is used.\n\n\nShow the code\n\n\ng &lt;- GAStech_graph %&gt;%\n  mutate(community = as.factor(\n    group_edge_betweenness(\n      weights = Weight, \n      directed = TRUE))) %&gt;%\n  ggraph(layout = \"fr\") + \n  geom_edge_link(\n    aes(\n      width=Weight), \n    alpha=0.2) +\n  scale_edge_width(\n    range = c(0.1, 5)) +\n  geom_node_point(\n    aes(colour = community))  \n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\nIn order to support effective visual investigation, the community network above has been revised by using geom_mark_hull() of ggforce package.\n\n\n\n\n\n\nImportant\n\n\n\n\nPlease be reminded that you must to install and include ggforce and concaveman packages before running the code chunk below.\n\n\n\n\n\nShow the code\n\n\ng &lt;- GAStech_graph %&gt;%\n  activate(nodes) %&gt;%\n  mutate(community = as.factor(\n    group_optimal(weights = Weight)),\n         betweenness_measure = centrality_betweenness()) %&gt;%\n  ggraph(layout = \"fr\") +\n  geom_mark_hull(\n    aes(x, y, \n        group = community, \n        fill = community),  \n    alpha = 0.2,  \n    expand = unit(0.3, \"cm\"),  # Expand\n    radius = unit(0.3, \"cm\")  # Smoothness\n  ) + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(fill = Department,\n                      size = betweenness_measure),\n                      color = \"black\",\n                      shape = 21)\n  \ng + theme_graph()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvisNetwork() is a R package for network visualization, using vis.js javascript library.\nvisNetwork() function uses a nodes list and edges list to create an interactive graph.\n\nThe nodes list must include an “id” column, and the edge list must have “from” and “to” columns.\nThe function also plots the labels for the nodes, using the names of the actors from the “label” column in the node list.\n\nThe resulting graph is fun to play around with.\n\nwe can move the nodes and the graph will use an algorithm to keep the nodes properly spaced.\nwe can also zoom in and out on the plot and move it around to re-center it.\n\n\n\n\nBefore we can plot the interactive network graph, we need to prepare the data model by using the code chunk below.\n\n\nShow the code\n\n\nGAStech_edges_aggregated &lt;- GAStech_edges %&gt;%\n  left_join(GAStech_nodes, by = c(\"sourceLabel\" = \"label\")) %&gt;%\n  rename(from = id) %&gt;%\n  left_join(GAStech_nodes, by = c(\"targetLabel\" = \"label\")) %&gt;%\n  rename(to = id) %&gt;%\n  filter(MainSubject == \"Work related\") %&gt;%\n  group_by(from, to) %&gt;%\n    summarise(weight = n()) %&gt;%\n  filter(from!=to) %&gt;%\n  filter(weight &gt; 1) %&gt;%\n  ungroup()\n\n\n\n\n\nThe code chunk below will be used to plot an interactive network graph by using the data prepared.\n\n\nShow the code\n\n\nvisNetwork(GAStech_nodes, \n           GAStech_edges_aggregated)\n\n\n\n\n\n\n\n\n\nIn the code chunk below, Fruchterman and Reingold layout is used.\n\n\nShow the code\n\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") \n\n\n\n\n\n\nVisit Igraph to find out more about visIgraphLayout’s argument.\n\n\n\nvisNetwork() looks for a field called “group” in the nodes object and colour the nodes according to the values of the group field.\nThe code chunk below rename Department field to group.\n\n\nShow the code\n\n\nGAStech_nodes &lt;- GAStech_nodes %&gt;%\n  rename(group = Department) \n\n\nWhen we rerun the code chunk below, visNetwork shades the nodes by assigning unique colour to each category in the group field.\n\n\nShow the code\n\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") %&gt;%\n  visLegend() %&gt;%\n  visLayout(randomSeed = 123)\n\n\n\n\n\n\n\n\n\nIn the code run below visEdges() is used to symbolise the edges.\n- The argument arrows is used to define where to place the arrow.\n- The smooth argument is used to plot the edges using a smooth curve.\n\n\nShow the code\n\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") %&gt;%\n  visEdges(arrows = \"to\", \n           smooth = list(enabled = TRUE, \n                         type = \"curvedCW\")) %&gt;%\n  visLegend() %&gt;%\n  visLayout(randomSeed = 123)\n\n\n\n\n\n\nVisit Option to find out more about visEdges’s argument.\n\n\n\nIn the code chunk below, visOptions() is used to incorporate interactivity features in the data visualisation.\n\nThe argument highlightNearest highlights nearest when clicking a node.\nThe argument nodesIdSelection adds an id node selection creating an HTML select element.\n\n\n\nShow the code\n\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") %&gt;%\n  visOptions(highlightNearest = TRUE,\n             nodesIdSelection = TRUE) %&gt;%\n  visLegend() %&gt;%\n  visLayout(randomSeed = 123)\n\n\n\n\n\n\nVisit Option to find out more about visOption’s argument.\n\n\n\n\n\n\n\n\nVisual Analysis of Complex Networks for Business Intelligence with Gephi\nGraph Drawing\nGraph Analytics - Lesson Learned and Challenges Ahead\nLearning to Read and Interpret Network Graph Data Visualizations\nThe Visualization of Networks\nViZster: Visualizing Online Social Networks\nAdam Perer. “Finding Beautiful Insights in the Chaos of Social Network Visualizations”. In ’‘’Beautiful Visualization’’’. O’Reilly Press.\nVisual Complexity"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#overview",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#overview",
    "title": "Hands-on Exercise 05",
    "section": "",
    "text": "In this hands-on exercise, we will learn how to model, analyse and visualise network data using R,\nto be able to:\n\ncreate graph object data frames, manipulate them using appropriate functions of dplyr, lubridate, and tidygraph,\nbuild network graph visualisation using appropriate functions of ggraph,\ncompute network geometrics using tidygraph,\nbuild advanced graph visualisation by incorporating the network geometrics, and\nbuild interactive network visualisation using visNetwork package."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#getting-started",
    "title": "Hands-on Exercise 05",
    "section": "",
    "text": "In this hands-on exercise, four network data modelling and visualisation packages will be installed and launched. They are igraph, tidygraph, ggraph and visNetwork. Beside these four packages, tidyverse and lubridate, an R package specially designed to handle and wrangling time data will be installed and launched too.\nThe code chunk:\n\n\nShow the code\n\n\npacman::p_load(igraph, tidygraph, ggraph, \n               visNetwork, lubridate, clock,\n               tidyverse, graphlayouts, \n               concaveman, ggforce)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#the-data",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#the-data",
    "title": "Hands-on Exercise 05",
    "section": "",
    "text": "The data sets used in this hands-on exercise is from an oil exploration and extraction company. There are two data sets. One contains the nodes data and the other contains the edges (also know as link) data.\n\n\n\nGAStech-email_edges.csv which consists of two weeks of 9063 emails correspondances between 55 employees.\n\n\n\n\n\n\nGAStech_email_nodes.csv which consist of the names, department and title of the 55 employees.\n\n\n\n\n\nIn this step, we will import GAStech_email_node.csv and GAStech_email_edges-v2.csv into RStudio environment by using read_csv() of readr package.\n\n\nShow the code\n\n\nGAStech_nodes &lt;- read_csv(\"data/GAStech_email_node.csv\")\nGAStech_edges &lt;- read_csv(\"data/GAStech_email_edge-v2.csv\")\n\n\n\n\n\nNext, we will examine the structure of the data frame using glimpse() of dplyr.\n\n\nShow the code\n\n\nglimpse(GAStech_edges)\n\nRows: 9,063\nColumns: 8\n$ source      &lt;dbl&gt; 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 26, 26, 26…\n$ target      &lt;dbl&gt; 41, 40, 51, 52, 53, 45, 44, 46, 48, 49, 47, 54, 27, 28, 29…\n$ SentDate    &lt;chr&gt; \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\"…\n$ SentTime    &lt;time&gt; 08:39:00, 08:39:00, 08:58:00, 08:58:00, 08:58:00, 08:58:0…\n$ Subject     &lt;chr&gt; \"GT-SeismicProcessorPro Bug Report\", \"GT-SeismicProcessorP…\n$ MainSubject &lt;chr&gt; \"Work related\", \"Work related\", \"Work related\", \"Work rela…\n$ sourceLabel &lt;chr&gt; \"Sven.Flecha\", \"Sven.Flecha\", \"Kanon.Herrero\", \"Kanon.Herr…\n$ targetLabel &lt;chr&gt; \"Isak.Baza\", \"Lucas.Alcazar\", \"Felix.Resumir\", \"Hideki.Coc…\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe output report of GAStech_edges above reveals that the SentDate is treated as “Character” data type instead of date data type. This is an error! Before we continue, it is important for us to change the data type of SentDate field back to “Date”” data type.\n\n\n\n\n\nThe code chunk below will be used to perform the changes.\n\n\nShow the code\n\n\nGAStech_edges &lt;- GAStech_edges %&gt;%\n  mutate(SendDate = dmy(SentDate)) %&gt;%\n  mutate(Weekday = wday(SentDate,\n                        label = TRUE,\n                        abbr = FALSE))\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nboth dmy() and wday() are functions of lubridate package. lubridate is an R package that makes it easier to work with dates and times.\ndmy() transforms the SentDate to Date data type.\nwday() returns the day of the week as a decimal number or an ordered factor if label is TRUE. The argument abbr is FALSE keep the daya spells in full, i.e. Monday. The function will create a new column in the data.frame i.e. Weekday and the output of wday() will save in this newly created field.\nthe values in the Weekday field are in ordinal scale.\n\n\n\n\n\n\nTable below shows the data structure of the reformatted GAStech_edges data frame\n\nglimpse(GAStech_edges)\n\nRows: 9,063\nColumns: 10\n$ source      &lt;dbl&gt; 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 26, 26, 26…\n$ target      &lt;dbl&gt; 41, 40, 51, 52, 53, 45, 44, 46, 48, 49, 47, 54, 27, 28, 29…\n$ SentDate    &lt;chr&gt; \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\"…\n$ SentTime    &lt;time&gt; 08:39:00, 08:39:00, 08:58:00, 08:58:00, 08:58:00, 08:58:0…\n$ Subject     &lt;chr&gt; \"GT-SeismicProcessorPro Bug Report\", \"GT-SeismicProcessorP…\n$ MainSubject &lt;chr&gt; \"Work related\", \"Work related\", \"Work related\", \"Work rela…\n$ sourceLabel &lt;chr&gt; \"Sven.Flecha\", \"Sven.Flecha\", \"Kanon.Herrero\", \"Kanon.Herr…\n$ targetLabel &lt;chr&gt; \"Isak.Baza\", \"Lucas.Alcazar\", \"Felix.Resumir\", \"Hideki.Coc…\n$ SendDate    &lt;date&gt; 2014-01-06, 2014-01-06, 2014-01-06, 2014-01-06, 2014-01-0…\n$ Weekday     &lt;ord&gt; Friday, Friday, Friday, Friday, Friday, Friday, Friday, Fr…\n\n\n\n\n\nA close examination of GAStech_edges data.frame reveals that it consists of individual e-mail flow records. This is not very useful for visualisation.\nIn view of this, we will aggregate the individual by date, senders, receivers, main subject and day of the week.\nThe code chunk:\n\n\nShow the code\n\n\nGAStech_edges_aggregated &lt;- GAStech_edges %&gt;%\n  filter(MainSubject == \"Work related\") %&gt;%\n  group_by(source, target, Weekday) %&gt;%\n    summarise(Weight = n()) %&gt;%\n  filter(source!=target) %&gt;%\n  filter(Weight &gt; 1) %&gt;%\n  ungroup()\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nfour functions from dplyr package are used. They are: filter(), group(), summarise(), and ungroup().\nThe output data.frame is called GAStech_edges_aggregated.\nA new field called Weight has been added in GAStech_edges_aggregated.\n\n\n\n\n\n\nTable below shows the data structure of the reformatted GAStech_edges_aggregated data frame\n\nglimpse(GAStech_edges_aggregated)\n\nRows: 1,372\nColumns: 4\n$ source  &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ target  &lt;dbl&gt; 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6,…\n$ Weekday &lt;ord&gt; Sunday, Monday, Tuesday, Wednesday, Friday, Sunday, Monday, Tu…\n$ Weight  &lt;int&gt; 5, 2, 3, 4, 6, 5, 2, 3, 4, 6, 5, 2, 3, 4, 6, 5, 2, 3, 4, 6, 5,…"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#creating-network-objects-using-tidygraph",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#creating-network-objects-using-tidygraph",
    "title": "Hands-on Exercise 05",
    "section": "",
    "text": "In this section, you will learn how to create a graph data model by using tidygraph package. It provides a tidy API for graph/network manipulation. While network data itself is not tidy, it can be envisioned as two tidy tables, one for node data and one for edge data. tidygraph provides a way to switch between the two tables and provides dplyr verbs for manipulating them. Furthermore it provides access to a lot of graph algorithms with return values that facilitate their use in a tidy workflow.\nBefore getting started, you are advised to read these two articles:\n\nIntroducing tidygraph\ntidygraph 1.1 - A tidy hope\n\n\n\nTwo functions of tidygraph package can be used to create network objects, they are:\n\ntbl_graph() creates a tbl_graph network object from nodes and edges data.\nas_tbl_graph() converts network data and objects to a tbl_graph network. Below are network data and objects supported by as_tbl_graph()\n\na node data.frame and an edge data.frame,\ndata.frame, list, matrix from base,\nigraph from igraph,\nnetwork from network,\ndendrogram and hclust from stats,\nNode from data.tree,\nphylo and evonet from ape, and\ngraphNEL, graphAM, graphBAM from graph (in Bioconductor).\n\n\n\n\n\n\nactivate() verb from tidygraph serves as a switch between tibbles for nodes and edges. All dplyr verbs applied to tbl_graph object are applied to the active tibble.\n\n\n\nIn the above the .N() function is used to gain access to the node data while manipulating the edge data. Similarly .E() will give you the edge data and .G() will give you the tbl_graph object itself.\n\n\n\n\nIn this section, we will use tbl_graph() of tinygraph package to build an tidygraph’s network graph data.frame.\nBefore typing the codes, it is recommended to review to reference guide of tbl_graph()\n\n\nShow the code\n\n\nGAStech_graph &lt;- tbl_graph(nodes = GAStech_nodes,\n                           edges = GAStech_edges_aggregated, \n                           directed = TRUE)\n\n\n\n\n\n\n\nShow the code\n\n\nGAStech_graph\n\n# A tbl_graph: 54 nodes and 1372 edges\n#\n# A directed multigraph with 1 component\n#\n# Node Data: 54 × 4 (active)\n      id label               Department     Title                               \n   &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt;          &lt;chr&gt;                               \n 1     1 Mat.Bramar          Administration Assistant to CEO                    \n 2     2 Anda.Ribera         Administration Assistant to CFO                    \n 3     3 Rachel.Pantanal     Administration Assistant to CIO                    \n 4     4 Linda.Lagos         Administration Assistant to COO                    \n 5     5 Ruscella.Mies.Haber Administration Assistant to Engineering Group Mana…\n 6     6 Carla.Forluniau     Administration Assistant to IT Group Manager       \n 7     7 Cornelia.Lais       Administration Assistant to Security Group Manager \n 8    44 Kanon.Herrero       Security       Badging Office                      \n 9    45 Varja.Lagos         Security       Badging Office                      \n10    46 Stenig.Fusil        Security       Building Control                    \n# ℹ 44 more rows\n#\n# Edge Data: 1,372 × 4\n   from    to Weekday Weight\n  &lt;int&gt; &lt;int&gt; &lt;ord&gt;    &lt;int&gt;\n1     1     2 Sunday       5\n2     1     2 Monday       2\n3     1     2 Tuesday      3\n# ℹ 1,369 more rows\n\n\n\n\n\n\n\nThe output above reveals that GAStech_graph is a tbl_graph object with 54 nodes and 4541 edges.\nThe command also prints the first six rows of “Node Data” and the first three of “Edge Data”.\nIt states that the Node Data is active. The notion of an active tibble within a tbl_graph object makes it possible to manipulate the data in one tibble at a time.\n\n\n\n\nThe nodes tibble data frame is activated by default, but you can change which tibble data frame is active with the activate() function. Thus, if we wanted to rearrange the rows in the edges tibble to list those with the highest “weight” first, we could use activate() and then arrange().\nFor example,\n\n\nShow the code\n\n\nGAStech_graph %&gt;%\n  activate(edges) %&gt;%\n  arrange(desc(Weight))\n\n# A tbl_graph: 54 nodes and 1372 edges\n#\n# A directed multigraph with 1 component\n#\n# Edge Data: 1,372 × 4 (active)\n    from    to Weekday   Weight\n   &lt;int&gt; &lt;int&gt; &lt;ord&gt;      &lt;int&gt;\n 1    40    41 Saturday      13\n 2    41    43 Monday        11\n 3    35    31 Tuesday       10\n 4    40    41 Monday        10\n 5    40    43 Monday        10\n 6    36    32 Sunday         9\n 7    40    43 Saturday       9\n 8    41    40 Monday         9\n 9    19    15 Wednesday      8\n10    35    38 Tuesday        8\n# ℹ 1,362 more rows\n#\n# Node Data: 54 × 4\n     id label           Department     Title           \n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;          &lt;chr&gt;           \n1     1 Mat.Bramar      Administration Assistant to CEO\n2     2 Anda.Ribera     Administration Assistant to CFO\n3     3 Rachel.Pantanal Administration Assistant to CIO\n# ℹ 51 more rows\n\n\n\nVisit the reference guide of activate() to find out more about the function."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#plotting-static-network-graphs-with-ggraph-package",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#plotting-static-network-graphs-with-ggraph-package",
    "title": "Hands-on Exercise 05",
    "section": "",
    "text": "ggraph is an extension of ggplot2, making it easier to carry over basic ggplot skills to the design of network graphs.\nAs in all network graph, there are three main aspects to a ggraph’s network graph, they are:\n\nnodes,\nedges and\nlayouts.\n\nFor a comprehensive discussion of each of this aspect of graph, please refer to their respective vignettes provided.\n\n\nThe code chunk below uses ggraph(), geom-edge_link() and geom_node_point() to plot a network graph by using GAStech_graph. Before your get started, it is advisable to read their respective reference guide at least once.\n\n\nShow the code\n\n\nggraph(GAStech_graph) +\n  geom_edge_link() +\n  geom_node_point()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nThe basic plotting function is ggraph(), which takes the data to be used for the graph and the type of layout desired. Both of the arguments for ggraph() are built around igraph. Therefore, ggraph() can use either an igraph object or a tbl_graph object.\n\n\n\n\n\n\nIn this section, you will use theme_graph() to remove the x and y axes. Before your get started, it is advisable to read it’s reference guide at least once.\n\n\nShow the code\n\n\ng &lt;- ggraph(GAStech_graph) + \n  geom_edge_link(aes()) +\n  geom_node_point(aes())\n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nggraph introduces a special ggplot theme that provides better defaults for network graphs than the normal ggplot defaults. theme_graph(), besides removing axes, grids, and border, changes the font to Arial Narrow (this can be overridden).\nThe ggraph theme can be set for a series of plots with the set_graph_style() command run before the graphs are plotted or by using theme_graph() in the individual plots.\n\n\n\n\n\n\nFurthermore, theme_graph() makes it easy to change the coloring of the plot.\n\n\nShow the code\n\n\ng &lt;- ggraph(GAStech_graph) + \n  geom_edge_link(aes(colour = 'grey50')) +\n  geom_node_point(aes(colour = 'grey40'))\n\ng + theme_graph(background = 'grey10',\n                text_colour = 'white')\n\n\n\n\n\n\n\n\n\n\n\n\nggraph support many layout for standard used, they are: star, circle, nicely (default), dh, gem, graphopt, grid, mds, spahere, randomly, fr, kk, drl and lgl. Figures below and on the right show layouts supported by ggraph().\n\n\n\n\nThe code chunks below will be used to plot the network graph using Fruchterman and Reingold layout.\n\n\nShow the code\n\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"fr\") +\n  geom_edge_link(aes()) +\n  geom_node_point(aes())\n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\nThing to learn from the code chunk above:\n\nlayout argument is used to define the layout to be used.\n\n\n\n\nIn this section, we will colour each node by referring to their respective departments.\n\n\nShow the code\n\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes()) +\n  geom_node_point(aes(colour = Department, \n                      size = 3))\n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunks above:\n\ngeom_node_point is equivalent in functionality to geo_point of ggplot2. It allows for simple plotting of nodes in different shapes, colours and sizes. In the codes chnuks above colour and size are used.\n\n\n\n\nIn the code chunk below, the thickness of the edges will be mapped with the Weight variable.\n\n\nShow the code\n\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") +\n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 3)\n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunks above:\n\ngeom_edge_link draws edges in the simplest way - as straight lines between the start and end nodes. But, it can do more that that. In the example above, argument width is used to map the width of the line in proportional to the Weight attribute and argument alpha is used to introduce opacity on the line."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#creating-facet-graphs",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#creating-facet-graphs",
    "title": "Hands-on Exercise 05",
    "section": "",
    "text": "Another very useful feature of ggraph is faceting. In visualising network data, this technique can be used to reduce edge over-plotting in a very meaning way by spreading nodes and edges out based on their attributes. In this section, we will learn how to use faceting technique to visualise network data.\nThere are three functions in ggraph to implement faceting, they are:\n\nfacet_nodes() whereby edges are only draw in a panel if both terminal nodes are present here,\nfacet_edges() whereby nodes are always drawn in al panels even if the node data contains an attribute named the same as the one used for the edge facetting, and\nfacet_graph() faceting on two variables simultaneously.\n\n\n\nIn the code chunk below, facet_edges() is used. Before getting started, it is advisable for us to read it’s reference guide at least once.\n\n\nShow the code\n\n\nset_graph_style()\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2)\n\ng + facet_edges(~Weekday)\n\n\n\n\n\n\n\n\n\n\n\n\nThe code chunk below uses theme() to change the position of the legend.\n\n\nShow the code\n\n\nset_graph_style()\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2) +\n  theme(legend.position = 'bottom')\n  \ng + facet_edges(~Weekday)\n\n\n\n\n\n\n\n\n\n\n\n\nThe code chunk below adds frame to each graph.\n\n\nShow the code\n\n\nset_graph_style() \n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2)\n  \ng + facet_edges(~Weekday) +\n  th_foreground(foreground = \"grey80\",  \n                border = TRUE) +\n  theme(legend.position = 'bottom')\n\n\n\n\n\n\n\n\n\n\n\n\nIn the code chunkc below, facet_nodes() is used. Before getting started, it is advisable for you to read it’s reference guide at least once.\n\n\nShow the code\n\n\nset_graph_style()\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2)\n  \ng + facet_nodes(~Department)+\n  th_foreground(foreground = \"grey80\",  \n                border = TRUE) +\n  theme(legend.position = 'bottom')"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#network-metrics-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#network-metrics-analysis",
    "title": "Hands-on Exercise 05",
    "section": "",
    "text": "Centrality measures are a collection of statistical indices use to describe the relative important of the actors are to a network. There are four well-known centrality measures, namely: degree, betweenness, closeness and eigenvector. It is beyond the scope of this hands-on exercise to cover the principles and mathematics of these measure here. Students are encouraged to refer to Chapter 7: Actor Prominence of A User’s Guide to Network Analysis in R to gain better understanding of theses network measures.\n\n\nShow the code\n\n\ng &lt;- GAStech_graph %&gt;%\n  mutate(betweenness_centrality = centrality_betweenness()) %&gt;%\n  ggraph(layout = \"fr\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department,\n            size=betweenness_centrality))\ng + theme_graph()\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\nmutate() of dplyr is used to perform the computation.\nthe algorithm used, on the other hand, is the centrality_betweenness() of tidygraph.\n\n\n\n\nIt is important to note that from ggraph v2.0 onward tidygraph algorithms such as centrality measures can be accessed directly in ggraph calls. This means that it is no longer necessary to precompute and store derived node and edge centrality measures on the graph in order to use them in a plot.\n\n\nShow the code\n\n\ng &lt;- GAStech_graph %&gt;%\n  ggraph(layout = \"fr\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department, \n                      size = centrality_betweenness()))\ng + theme_graph()\n\n\n\n\n\n\n\n\n\n\n\n\ntidygraph package inherits many of the community detection algorithms imbedded into igraph and makes them available to us, including Edge-betweenness (group_edge_betweenness), Leading eigenvector (group_leading_eigen), Fast-greedy (group_fast_greedy), Louvain (group_louvain), Walktrap (group_walktrap), Label propagation (group_label_prop), InfoMAP (group_infomap), Spinglass (group_spinglass), and Optimal (group_optimal). Some community algorithms are designed to take into account direction or weight, while others ignore it. Use this link to find out more about community detection functions provided by tidygraph,\nIn the code chunk below group_edge_betweenness() is used.\n\n\nShow the code\n\n\ng &lt;- GAStech_graph %&gt;%\n  mutate(community = as.factor(\n    group_edge_betweenness(\n      weights = Weight, \n      directed = TRUE))) %&gt;%\n  ggraph(layout = \"fr\") + \n  geom_edge_link(\n    aes(\n      width=Weight), \n    alpha=0.2) +\n  scale_edge_width(\n    range = c(0.1, 5)) +\n  geom_node_point(\n    aes(colour = community))  \n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\nIn order to support effective visual investigation, the community network above has been revised by using geom_mark_hull() of ggforce package.\n\n\n\n\n\n\nImportant\n\n\n\n\nPlease be reminded that you must to install and include ggforce and concaveman packages before running the code chunk below.\n\n\n\n\n\nShow the code\n\n\ng &lt;- GAStech_graph %&gt;%\n  activate(nodes) %&gt;%\n  mutate(community = as.factor(\n    group_optimal(weights = Weight)),\n         betweenness_measure = centrality_betweenness()) %&gt;%\n  ggraph(layout = \"fr\") +\n  geom_mark_hull(\n    aes(x, y, \n        group = community, \n        fill = community),  \n    alpha = 0.2,  \n    expand = unit(0.3, \"cm\"),  # Expand\n    radius = unit(0.3, \"cm\")  # Smoothness\n  ) + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(fill = Department,\n                      size = betweenness_measure),\n                      color = \"black\",\n                      shape = 21)\n  \ng + theme_graph()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#building-interactive-network-graph-with-visnetwork",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#building-interactive-network-graph-with-visnetwork",
    "title": "Hands-on Exercise 05",
    "section": "",
    "text": "visNetwork() is a R package for network visualization, using vis.js javascript library.\nvisNetwork() function uses a nodes list and edges list to create an interactive graph.\n\nThe nodes list must include an “id” column, and the edge list must have “from” and “to” columns.\nThe function also plots the labels for the nodes, using the names of the actors from the “label” column in the node list.\n\nThe resulting graph is fun to play around with.\n\nwe can move the nodes and the graph will use an algorithm to keep the nodes properly spaced.\nwe can also zoom in and out on the plot and move it around to re-center it.\n\n\n\n\nBefore we can plot the interactive network graph, we need to prepare the data model by using the code chunk below.\n\n\nShow the code\n\n\nGAStech_edges_aggregated &lt;- GAStech_edges %&gt;%\n  left_join(GAStech_nodes, by = c(\"sourceLabel\" = \"label\")) %&gt;%\n  rename(from = id) %&gt;%\n  left_join(GAStech_nodes, by = c(\"targetLabel\" = \"label\")) %&gt;%\n  rename(to = id) %&gt;%\n  filter(MainSubject == \"Work related\") %&gt;%\n  group_by(from, to) %&gt;%\n    summarise(weight = n()) %&gt;%\n  filter(from!=to) %&gt;%\n  filter(weight &gt; 1) %&gt;%\n  ungroup()\n\n\n\n\n\nThe code chunk below will be used to plot an interactive network graph by using the data prepared.\n\n\nShow the code\n\n\nvisNetwork(GAStech_nodes, \n           GAStech_edges_aggregated)\n\n\n\n\n\n\n\n\n\nIn the code chunk below, Fruchterman and Reingold layout is used.\n\n\nShow the code\n\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") \n\n\n\n\n\n\nVisit Igraph to find out more about visIgraphLayout’s argument.\n\n\n\nvisNetwork() looks for a field called “group” in the nodes object and colour the nodes according to the values of the group field.\nThe code chunk below rename Department field to group.\n\n\nShow the code\n\n\nGAStech_nodes &lt;- GAStech_nodes %&gt;%\n  rename(group = Department) \n\n\nWhen we rerun the code chunk below, visNetwork shades the nodes by assigning unique colour to each category in the group field.\n\n\nShow the code\n\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") %&gt;%\n  visLegend() %&gt;%\n  visLayout(randomSeed = 123)\n\n\n\n\n\n\n\n\n\nIn the code run below visEdges() is used to symbolise the edges.\n- The argument arrows is used to define where to place the arrow.\n- The smooth argument is used to plot the edges using a smooth curve.\n\n\nShow the code\n\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") %&gt;%\n  visEdges(arrows = \"to\", \n           smooth = list(enabled = TRUE, \n                         type = \"curvedCW\")) %&gt;%\n  visLegend() %&gt;%\n  visLayout(randomSeed = 123)\n\n\n\n\n\n\nVisit Option to find out more about visEdges’s argument.\n\n\n\nIn the code chunk below, visOptions() is used to incorporate interactivity features in the data visualisation.\n\nThe argument highlightNearest highlights nearest when clicking a node.\nThe argument nodesIdSelection adds an id node selection creating an HTML select element.\n\n\n\nShow the code\n\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") %&gt;%\n  visOptions(highlightNearest = TRUE,\n             nodesIdSelection = TRUE) %&gt;%\n  visLegend() %&gt;%\n  visLayout(randomSeed = 123)\n\n\n\n\n\n\nVisit Option to find out more about visOption’s argument."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#readings",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#readings",
    "title": "Hands-on Exercise 05",
    "section": "",
    "text": "Visual Analysis of Complex Networks for Business Intelligence with Gephi\nGraph Drawing\nGraph Analytics - Lesson Learned and Challenges Ahead\nLearning to Read and Interpret Network Graph Data Visualizations\nThe Visualization of Networks\nViZster: Visualizing Online Social Networks\nAdam Perer. “Finding Beautiful Insights in the Chaos of Social Network Visualizations”. In ’‘’Beautiful Visualization’’’. O’Reilly Press.\nVisual Complexity"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html",
    "href": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html",
    "title": "Hands-on Exercise 04C",
    "section": "",
    "text": "Visualizing uncertainty is relatively new in statistical graphics. In this exercise, we will gain hands-on experience on creating statistical graphics for visualising uncertainty. By the end of this exercise we will be able:\n\nto plot statistics error bars by using ggplot2,\nto plot interactive error bars by combining ggplot2, plotly and DT,\nto create advanced by using ggdist, and\nto create hypothetical outcome plots (HOPs) by using ungeviz package.\n\n\n\n\n\n\nFor the purpose of this exercise, the following R packages will be used, they are:\n\ntidyverse, a family of R packages for data science process,\nplotly for creating interactive plot,\ngganimate for creating animation plot,\nDT for displaying interactive html table,\ncrosstalk for for implementing cross-widget interactions (currently, linked brushing and filtering), and\nggdist for visualising distribution and uncertainty.\n\n\npacman::p_load(plotly, crosstalk, DT, \n               ggdist, ggridges, colorspace,\n               gganimate, tidyverse)\n\n\n\n\nFor the purpose of this exercise, Exam_data.csv will be used.\n\nexam &lt;- read_csv(\"data/Exam_data.csv\")\n\n\n\n\n\nA point estimate is a single number, such as a mean. Uncertainty, on the other hand, is expressed as standard error, confidence interval, or credible interval.\n\n\n\n\n\n\nImportant\n\n\n\n\nDon’t confuse the uncertainty of a point estimate with the variation in the sample\n\n\n\nIn this section, we will learn how to plot error bars of maths scores by race by using data provided in exam tibble data frame.\nFirstly, code chunk below will be used to derive the necessary summary statistics.\n\nmy_sum &lt;- exam %&gt;%\n  group_by(RACE) %&gt;%\n  summarise(\n    n=n(),\n    mean=mean(MATHS),\n    sd=sd(MATHS)\n    ) %&gt;%\n  mutate(se=sd/sqrt(n-1))\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\ngroup_by() of dplyr package is used to group the observation by RACE,\nsummarise() is used to compute the count of observations, mean, standard deviation\nmutate() is used to derive standard error of Maths by RACE, and\nthe output is save as a tibble data table called my_sum.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nFor the mathematical explanation, please refer to Slide 20 of Lesson 4.\n\n\n\nNext, the code chunk below will be used to display my_sum tibble data frame in an html table format.\n\nThe code chunkThe Table\n\n\n\nknitr::kable(head(my_sum), format = 'html')\n\n\n\n\nknitr::kable(head(my_sum), format = 'html')\n\n\n\n\nRACE\nn\nmean\nsd\nse\n\n\n\n\nChinese\n193\n76.50777\n15.69040\n1.132357\n\n\nIndian\n12\n60.66667\n23.35237\n7.041005\n\n\nMalay\n108\n57.44444\n21.13478\n2.043177\n\n\nOthers\n9\n69.66667\n10.72381\n3.791438\n\n\n\n\n\n\n\n\n\n\n\n\nNow we are ready to plot the standard error bars of mean maths score by race as shown below.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(my_sum) +\n  geom_errorbar(\n    aes(x=RACE, \n        ymin=mean-se, \n        ymax=mean+se), \n    width=0.2, \n    colour=\"black\", \n    alpha=0.9, \n    linewidth=0.5) +\n  geom_point(aes\n           (x=RACE, \n            y=mean), \n           stat=\"identity\", \n           color=\"red\",\n           size = 1.5,\n           alpha=1) +\n  ggtitle(\"Standard error of mean maths score by rac\")\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nThe error bars are computed by using the formula mean+/-se.\nFor geom_point(), it is important to indicate stat=“identity”.\n\n\n\n\n\n\n\n\n\nInstead of plotting the standard error bar of point estimates, we can also plot the confidence intervals of mean maths score by race.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(my_sum) +\n  geom_errorbar(\n    aes(x=reorder(RACE, -mean), \n        ymin=mean-1.96*se, \n        ymax=mean+1.96*se), \n    width=0.2, \n    colour=\"black\", \n    alpha=0.9, \n    linewidth=0.5) +\n  geom_point(aes\n           (x=RACE, \n            y=mean), \n           stat=\"identity\", \n           color=\"red\",\n           size = 1.5,\n           alpha=1) +\n  labs(x = \"Maths score\",\n       title = \"95% confidence interval of mean maths score by race\")\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nThe confidence intervals are computed by using the formula mean+/-1.96*se.\nThe error bars is sorted by using the average maths scores.\nlabs() argument of ggplot2 is used to change the x-axis label.\n\n\n\n\n\n\n\n\n\nIn this section, you will learn how to plot interactive error bars for the 99% confidence interval of mean maths score by race as shown in the figure below.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nshared_df = SharedData$new(my_sum)\n\nbscols(widths = c(4,8),\n       ggplotly((ggplot(shared_df) +\n                   geom_errorbar(aes(\n                     x=reorder(RACE, -mean),\n                     ymin=mean-2.58*se, \n                     ymax=mean+2.58*se), \n                     width=0.2, \n                     colour=\"black\", \n                     alpha=0.9, \n                     size=0.5) +\n                   geom_point(aes(\n                     x=RACE, \n                     y=mean, \n                     text = paste(\"Race:\", `RACE`, \n                                  \"&lt;br&gt;N:\", `n`,\n                                  \"&lt;br&gt;Avg. Scores:\", round(mean, digits = 2),\n                                  \"&lt;br&gt;95% CI:[\", \n                                  round((mean-2.58*se), digits = 2), \",\",\n                                  round((mean+2.58*se), digits = 2),\"]\")),\n                     stat=\"identity\", \n                     color=\"red\", \n                     size = 1.5, \n                     alpha=1) + \n                   xlab(\"Race\") + \n                   ylab(\"Average Scores\") + \n                   theme_minimal() + \n                   theme(axis.text.x = element_text(\n                     angle = 45, vjust = 0.5, hjust=1)) +\n                   ggtitle(\"99% Confidence interval of average /&lt;br&gt;maths scores by race\")), \n                tooltip = \"text\"), \n       DT::datatable(shared_df, \n                     rownames = FALSE, \n                     class=\"compact\", \n                     width=\"100%\", \n                     options = list(pageLength = 10,\n                                    scrollX=T), \n                     colnames = c(\"No. of pupils\", \n                                  \"Avg Scores\",\n                                  \"Std Dev\",\n                                  \"Std Error\")) %&gt;%\n         formatRound(columns=c('mean', 'sd', 'se'),\n                     digits=2))\n\n\n\n\n\n\n\n\n\nggdist is an R package that provides a flexible set of ggplot2 geoms and stats designed especially for visualising distributions and uncertainty.\nIt is designed for both frequentist and Bayesian uncertainty visualization, taking the view that uncertainty visualization can be unified through the perspective of distribution visualization:\n\nfor frequentist models, one visualises confidence distributions or bootstrap distributions (see vignette(“freq-uncertainty-vis”));\nfor Bayesian models, one visualises probability distributions (see the tidybayes package, which builds on top of ggdist).\n\n\n\n\n\nIn the code chunk below, stat_pointinterval() of ggdist is used to build a visual for displaying distribution of maths scores by race.\n\nexam %&gt;%\n  ggplot(aes(x = RACE, \n             y = MATHS)) +\n  stat_pointinterval() +\n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Mean Point + Multiple-interval plot\")\n\n\n\n\n\n\n\n\nFor example, in the code chunk below the following arguments are used:\n.width = 0.95 .point = median .interval = qi\n\nexam %&gt;%\n  ggplot(aes(x = RACE, y = MATHS)) +\n  stat_pointinterval(.width = 0.95,\n  .point = median,\n  .interval = qi) +\n  labs(\n    title = \"Visualising confidence intervals of median math score\",\n    subtitle = \"Median Point + Multiple-interval plot\")\n\n\n\n\n\n\n\n\n\n\n\nPlot below shows 95% and 99% Confidence Interval\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexam %&gt;%\n  ggplot(aes(x = RACE, y = MATHS)) +\n  stat_pointinterval(\n    .width = 0.95,\n    .point = \"median\",\n    .interval = \"quantile\",\n    aes(colour = \"95% CI\")) +\n  stat_pointinterval(\n    .width = 0.99,\n    .point = \"median\",\n    .interval = \"quantile\",\n    aes(colour = \"99% CI\")) +\n  scale_colour_manual(\n    values = c(\"95% CI\" = \"green\", \"99% CI\" = \"red\"),\n    labels = c(\"95% CI\", \"99% CI\")) +\n  labs(\n    title = \"Visualising confidence intervals of median math score\",\n    subtitle = \"Median Point + Multiple-interval plot\") +\n  theme_minimal()\n\n\n\n\n\n\n\nIn the code chunk below, stat_gradientinterval() of ggdist is used to build a visual for displaying distribution of maths scores by race.\n\nexam %&gt;%\n  ggplot(aes(x = RACE, \n             y = MATHS)) +\n  stat_gradientinterval(   \n    fill = \"skyblue\",      \n    show.legend = TRUE     \n  ) +                        \n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Gradient + interval plot\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndevtools::install_github(\"wilkelab/ungeviz\")\n\nNote: We only need to perform this step once.\n\n\n\n\nlibrary(ungeviz)\n\n\n\n\nNext, the code chunk below will be used to build the HOPs.\n\nggplot(data = exam, \n       (aes(x = factor(RACE), \n            y = MATHS))) +\n  geom_point(position = position_jitter(\n    height = 0.3, \n    width = 0.05), \n    size = 0.4, \n    color = \"#0072B2\", \n    alpha = 1/2) +\n  geom_hpline(data = sampler(25, \n                             group = RACE), \n              height = 0.6, \n              color = \"#D55E00\") +\n  theme_bw() + \n  transition_states(.draw, 1, 3)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html#learning-outcome",
    "href": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html#learning-outcome",
    "title": "Hands-on Exercise 04C",
    "section": "",
    "text": "Visualizing uncertainty is relatively new in statistical graphics. In this exercise, we will gain hands-on experience on creating statistical graphics for visualising uncertainty. By the end of this exercise we will be able:\n\nto plot statistics error bars by using ggplot2,\nto plot interactive error bars by combining ggplot2, plotly and DT,\nto create advanced by using ggdist, and\nto create hypothetical outcome plots (HOPs) by using ungeviz package."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html#getting-started",
    "title": "Hands-on Exercise 04C",
    "section": "",
    "text": "For the purpose of this exercise, the following R packages will be used, they are:\n\ntidyverse, a family of R packages for data science process,\nplotly for creating interactive plot,\ngganimate for creating animation plot,\nDT for displaying interactive html table,\ncrosstalk for for implementing cross-widget interactions (currently, linked brushing and filtering), and\nggdist for visualising distribution and uncertainty.\n\n\npacman::p_load(plotly, crosstalk, DT, \n               ggdist, ggridges, colorspace,\n               gganimate, tidyverse)\n\n\n\n\nFor the purpose of this exercise, Exam_data.csv will be used.\n\nexam &lt;- read_csv(\"data/Exam_data.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html#visualizing-the-uncertainty-of-point-estimates-ggplot2-methods",
    "href": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html#visualizing-the-uncertainty-of-point-estimates-ggplot2-methods",
    "title": "Hands-on Exercise 04C",
    "section": "",
    "text": "A point estimate is a single number, such as a mean. Uncertainty, on the other hand, is expressed as standard error, confidence interval, or credible interval.\n\n\n\n\n\n\nImportant\n\n\n\n\nDon’t confuse the uncertainty of a point estimate with the variation in the sample\n\n\n\nIn this section, we will learn how to plot error bars of maths scores by race by using data provided in exam tibble data frame.\nFirstly, code chunk below will be used to derive the necessary summary statistics.\n\nmy_sum &lt;- exam %&gt;%\n  group_by(RACE) %&gt;%\n  summarise(\n    n=n(),\n    mean=mean(MATHS),\n    sd=sd(MATHS)\n    ) %&gt;%\n  mutate(se=sd/sqrt(n-1))\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\ngroup_by() of dplyr package is used to group the observation by RACE,\nsummarise() is used to compute the count of observations, mean, standard deviation\nmutate() is used to derive standard error of Maths by RACE, and\nthe output is save as a tibble data table called my_sum.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nFor the mathematical explanation, please refer to Slide 20 of Lesson 4.\n\n\n\nNext, the code chunk below will be used to display my_sum tibble data frame in an html table format.\n\nThe code chunkThe Table\n\n\n\nknitr::kable(head(my_sum), format = 'html')\n\n\n\n\nknitr::kable(head(my_sum), format = 'html')\n\n\n\n\nRACE\nn\nmean\nsd\nse\n\n\n\n\nChinese\n193\n76.50777\n15.69040\n1.132357\n\n\nIndian\n12\n60.66667\n23.35237\n7.041005\n\n\nMalay\n108\n57.44444\n21.13478\n2.043177\n\n\nOthers\n9\n69.66667\n10.72381\n3.791438\n\n\n\n\n\n\n\n\n\n\n\n\nNow we are ready to plot the standard error bars of mean maths score by race as shown below.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(my_sum) +\n  geom_errorbar(\n    aes(x=RACE, \n        ymin=mean-se, \n        ymax=mean+se), \n    width=0.2, \n    colour=\"black\", \n    alpha=0.9, \n    linewidth=0.5) +\n  geom_point(aes\n           (x=RACE, \n            y=mean), \n           stat=\"identity\", \n           color=\"red\",\n           size = 1.5,\n           alpha=1) +\n  ggtitle(\"Standard error of mean maths score by rac\")\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nThe error bars are computed by using the formula mean+/-se.\nFor geom_point(), it is important to indicate stat=“identity”.\n\n\n\n\n\n\n\n\n\nInstead of plotting the standard error bar of point estimates, we can also plot the confidence intervals of mean maths score by race.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(my_sum) +\n  geom_errorbar(\n    aes(x=reorder(RACE, -mean), \n        ymin=mean-1.96*se, \n        ymax=mean+1.96*se), \n    width=0.2, \n    colour=\"black\", \n    alpha=0.9, \n    linewidth=0.5) +\n  geom_point(aes\n           (x=RACE, \n            y=mean), \n           stat=\"identity\", \n           color=\"red\",\n           size = 1.5,\n           alpha=1) +\n  labs(x = \"Maths score\",\n       title = \"95% confidence interval of mean maths score by race\")\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\n\nThe confidence intervals are computed by using the formula mean+/-1.96*se.\nThe error bars is sorted by using the average maths scores.\nlabs() argument of ggplot2 is used to change the x-axis label.\n\n\n\n\n\n\n\n\n\nIn this section, you will learn how to plot interactive error bars for the 99% confidence interval of mean maths score by race as shown in the figure below.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nshared_df = SharedData$new(my_sum)\n\nbscols(widths = c(4,8),\n       ggplotly((ggplot(shared_df) +\n                   geom_errorbar(aes(\n                     x=reorder(RACE, -mean),\n                     ymin=mean-2.58*se, \n                     ymax=mean+2.58*se), \n                     width=0.2, \n                     colour=\"black\", \n                     alpha=0.9, \n                     size=0.5) +\n                   geom_point(aes(\n                     x=RACE, \n                     y=mean, \n                     text = paste(\"Race:\", `RACE`, \n                                  \"&lt;br&gt;N:\", `n`,\n                                  \"&lt;br&gt;Avg. Scores:\", round(mean, digits = 2),\n                                  \"&lt;br&gt;95% CI:[\", \n                                  round((mean-2.58*se), digits = 2), \",\",\n                                  round((mean+2.58*se), digits = 2),\"]\")),\n                     stat=\"identity\", \n                     color=\"red\", \n                     size = 1.5, \n                     alpha=1) + \n                   xlab(\"Race\") + \n                   ylab(\"Average Scores\") + \n                   theme_minimal() + \n                   theme(axis.text.x = element_text(\n                     angle = 45, vjust = 0.5, hjust=1)) +\n                   ggtitle(\"99% Confidence interval of average /&lt;br&gt;maths scores by race\")), \n                tooltip = \"text\"), \n       DT::datatable(shared_df, \n                     rownames = FALSE, \n                     class=\"compact\", \n                     width=\"100%\", \n                     options = list(pageLength = 10,\n                                    scrollX=T), \n                     colnames = c(\"No. of pupils\", \n                                  \"Avg Scores\",\n                                  \"Std Dev\",\n                                  \"Std Error\")) %&gt;%\n         formatRound(columns=c('mean', 'sd', 'se'),\n                     digits=2))"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html#visualizing-uncertainty-ggdist-package",
    "href": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html#visualizing-uncertainty-ggdist-package",
    "title": "Hands-on Exercise 04C",
    "section": "",
    "text": "ggdist is an R package that provides a flexible set of ggplot2 geoms and stats designed especially for visualising distributions and uncertainty.\nIt is designed for both frequentist and Bayesian uncertainty visualization, taking the view that uncertainty visualization can be unified through the perspective of distribution visualization:\n\nfor frequentist models, one visualises confidence distributions or bootstrap distributions (see vignette(“freq-uncertainty-vis”));\nfor Bayesian models, one visualises probability distributions (see the tidybayes package, which builds on top of ggdist).\n\n\n\n\n\nIn the code chunk below, stat_pointinterval() of ggdist is used to build a visual for displaying distribution of maths scores by race.\n\nexam %&gt;%\n  ggplot(aes(x = RACE, \n             y = MATHS)) +\n  stat_pointinterval() +\n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Mean Point + Multiple-interval plot\")\n\n\n\n\n\n\n\n\nFor example, in the code chunk below the following arguments are used:\n.width = 0.95 .point = median .interval = qi\n\nexam %&gt;%\n  ggplot(aes(x = RACE, y = MATHS)) +\n  stat_pointinterval(.width = 0.95,\n  .point = median,\n  .interval = qi) +\n  labs(\n    title = \"Visualising confidence intervals of median math score\",\n    subtitle = \"Median Point + Multiple-interval plot\")\n\n\n\n\n\n\n\n\n\n\n\nPlot below shows 95% and 99% Confidence Interval\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexam %&gt;%\n  ggplot(aes(x = RACE, y = MATHS)) +\n  stat_pointinterval(\n    .width = 0.95,\n    .point = \"median\",\n    .interval = \"quantile\",\n    aes(colour = \"95% CI\")) +\n  stat_pointinterval(\n    .width = 0.99,\n    .point = \"median\",\n    .interval = \"quantile\",\n    aes(colour = \"99% CI\")) +\n  scale_colour_manual(\n    values = c(\"95% CI\" = \"green\", \"99% CI\" = \"red\"),\n    labels = c(\"95% CI\", \"99% CI\")) +\n  labs(\n    title = \"Visualising confidence intervals of median math score\",\n    subtitle = \"Median Point + Multiple-interval plot\") +\n  theme_minimal()\n\n\n\n\n\n\n\nIn the code chunk below, stat_gradientinterval() of ggdist is used to build a visual for displaying distribution of maths scores by race.\n\nexam %&gt;%\n  ggplot(aes(x = RACE, \n             y = MATHS)) +\n  stat_gradientinterval(   \n    fill = \"skyblue\",      \n    show.legend = TRUE     \n  ) +                        \n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Gradient + interval plot\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html#visualising-uncertainty-with-hypothetical-outcome-plots-hops",
    "href": "Hands-on_Ex/Hands-on_Ex04C/Hands-on_Ex04C.html#visualising-uncertainty-with-hypothetical-outcome-plots-hops",
    "title": "Hands-on Exercise 04C",
    "section": "",
    "text": "devtools::install_github(\"wilkelab/ungeviz\")\n\nNote: We only need to perform this step once.\n\n\n\n\nlibrary(ungeviz)\n\n\n\n\nNext, the code chunk below will be used to build the HOPs.\n\nggplot(data = exam, \n       (aes(x = factor(RACE), \n            y = MATHS))) +\n  geom_point(position = position_jitter(\n    height = 0.3, \n    width = 0.05), \n    size = 0.4, \n    color = \"#0072B2\", \n    alpha = 1/2) +\n  geom_hpline(data = sampler(25, \n                             group = RACE), \n              height = 0.6, \n              color = \"#D55E00\") +\n  theme_bw() + \n  transition_states(.draw, 1, 3)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html",
    "href": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html",
    "title": "Hands-on Exercise 04A",
    "section": "",
    "text": "Visualizing distribution is not new in statistical analysis. In chapter 1 we have shared with you some of the popular statistical graphics methods for visualizing distribution are histogram, probability density curve (pdf), boxplot, notch plot and violin plot and how they can be created by using ggplot2. In this chapter, we are going to share with you two relatively new statistical graphic methods for visualizing distribution, namely ridgeline plot and raincloud plot by using ggplot2 and its extensions.\n\n\n\n\n\nFor the purpose of this exercise, the following R packages will be used, they are:\n\nggridges, a ggplot2 extension specially designed for plotting ridgeline plots,\nggdist, a ggplot2 extension spacially desgin for visualizing distribution and uncertainty,\ntidyverse, a family of R packages to meet the modern data science and visual communication needs,\nggthemes, a ggplot extension that provides the user additional themes, scales, and geoms for the ggplots package, and\ncolorspace, an R package provides a broad toolbox for selecting individual colors or color palettes, manipulating these colors, and employing them in various kinds of visualizations.\n\nThe code chunk below will be used load these R packages into RStudio environment.\n\npacman::p_load(ggdist, ggridges, ggthemes,\n               colorspace, tidyverse)\n\n\n\n\nFor the purpose of this exercise, Exam_data.csv will be used.\nIn the code chunk below, read_csv() of readr package is used to import Exam_data.csv into R and saved it into a tibble data.frame.\n\nexam &lt;- read_csv(\"data/Exam_data.csv\")\n\n\n\n\n\nRidgeline plot (sometimes called Joyplot) is a data visualization technique for revealing the distribution of a numeric value for several groups. Distribution can be represented using histograms or density plots, all aligned to the same horizontal scale and presented with a slight overlap.\nFigure below is a ridgelines plot showing the distribution of English score by class.\n\n# Load libraries\nlibrary(ggplot2)\nlibrary(ggridges)\n\n# Plot\nggplot(exam, aes(x = ENGLISH, y = CLASS)) +\n  geom_density_ridges(\n    scale = 1.2,\n    rel_min_height = 0.01,\n    fill = \"gray\",\n    color = \"black\"\n  ) +\n  scale_x_continuous(\n    name = \"ENGLISH\",\n    expand = c(0, 0)\n  ) +\n  scale_y_discrete(\n    name = \"CLASS\",\n    expand = expansion(add = c(0.2, 0.5))\n  ) +\n  theme_minimal(base_size = 14) +  # Clean base theme\n  theme(\n    panel.grid.major.x = element_line(color =\"whitesmoke\"),  # vertical lines\n    panel.grid.major.y = element_line(color = \"whitesmoke\"),  # horizontal lines\n    panel.grid.minor = element_blank(),                   # no minor gridlines\n    panel.background = element_rect(fill = \"white\", color = NA),  # white background\n    plot.background = element_rect(fill = \"white\", color = NA)\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nRidgeline plots make sense when the number of groups to represent is medium to high. A classic window separation would take up too much space. The overlapping design of ridgelines makes better use of space. If you have fewer than 5 groups, other distribution plots may be more effective.\nRidgeline plots work well when there’s a clear pattern or ranking among groups. Otherwise, excessive overlap may lead to a messy plot with little insight.\n\n\n\n\n\nThere are several ways to plot ridgeline plot with R. In this section, you will learn how to plot ridgeline plot by using ggridges package.\nggridges package provides two main geom to plot gridgeline plots, they are: geom_ridgeline() and geom_density_ridges(). The former takes height values directly to draw the ridgelines, and the latter first estimates data densities and then draws those using ridgelines.\nThe ridgeline plot below is plotted by using geom_density_ridges().\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = ENGLISH, \n           y = CLASS)) +\n  geom_density_ridges(\n    scale = 3,\n    rel_min_height = 0.01,\n    bandwidth = 3.4,\n    fill = lighten(\"#7097BB\", .3),\n    color = \"white\"\n  ) +\n  scale_x_continuous(\n    name = \"English grades\",\n    expand = c(0, 0)\n    ) +\n  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +\n  theme_ridges()\n\n\n\n\n\n\n\nSometimes we would like to have the area under a ridgeline not filled with a single solid color but rather with colors that vary in some form along the x axis. This effect can be achieved by using either geom_ridgeline_gradient() or geom_density_ridges_gradient(). Both geoms work just like geom_ridgeline() and geom_density_ridges(), except that they allow for varying fill colors. However, they do not allow for alpha transparency in the fill. For technical reasons, we can have changing fill colors or transparency but not both.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = ENGLISH, \n           y = CLASS,\n           fill = stat(x))) +\n  geom_density_ridges_gradient(\n    scale = 3,\n    rel_min_height = 0.01) +\n  scale_fill_viridis_c(name = \"Temp. [F]\",\n                       option = \"C\") +\n  scale_x_continuous(\n    name = \"English grades\",\n    expand = c(0, 0)\n  ) +\n  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +\n  theme_ridges()\n\n\n\n\n\n\n\nBeside providing additional geom objects to support the need to plot ridgeline plot, ggridges package also provides a stat function called stat_density_ridges() that replaces stat_density() of ggplot2.\nFigure below is plotted by mapping the probabilities calculated by using stat(ecdf) which represent the empirical cumulative density function for the distribution of English score.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam,\n       aes(x = ENGLISH, \n           y = CLASS, \n           fill = 0.5 - abs(0.5-stat(ecdf)))) +\n  stat_density_ridges(geom = \"density_ridges_gradient\", \n                      calc_ecdf = TRUE) +\n  scale_fill_viridis_c(name = \"Tail probability\",\n                       direction = -1) +\n  theme_ridges()\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nIt is important to include the argument calc_ecdf = TRUE in stat_density_ridges().\n\n\n\n\n\nBy using geom_density_ridges_gradient(), we can colour the ridgeline plot by quantile, via the calculated stat(quantile) aesthetic as shown in the figure below.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam,\n       aes(x = ENGLISH, \n           y = CLASS, \n           fill = factor(stat(quantile))\n           )) +\n  stat_density_ridges(\n    geom = \"density_ridges_gradient\",\n    calc_ecdf = TRUE, \n    quantiles = 4,\n    quantile_lines = TRUE) +\n  scale_fill_viridis_d(name = \"Quartiles\") +\n  theme_ridges()\n\n\n\n\nInstead of using number to define the quantiles, we can also specify quantiles by cut points such as 2.5% and 97.5% tails to colour the ridgeline plot as shown in the figure below.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam,\n       aes(x = ENGLISH, \n           y = CLASS, \n           fill = factor(stat(quantile))\n           )) +\n  stat_density_ridges(\n    geom = \"density_ridges_gradient\",\n    calc_ecdf = TRUE, \n    quantiles = c(0.025, 0.975)\n    ) +\n  scale_fill_manual(\n    name = \"Probability\",\n    values = c(\"#FF0000A0\", \"#A0A0A0A0\", \"#0000FFA0\"),\n    labels = c(\"(0, 0.025]\", \"(0.025, 0.975]\", \"(0.975, 1]\")\n  ) +\n  theme_ridges()\n\n\n\n\n\n\n\n\nRaincloud Plot is a data visualization techniques that produces a half-density to a distribution plot. It gets the name because the density plot is in the shape of a “raincloud”. The raincloud (half-density) plot enhances the traditional box-plot by highlighting multiple modalities (an indicator that groups may exist). The boxplot does not show where densities are clustered, but the raincloud plot does!\nIn this section, you will learn how to create a raincloud plot to visualize the distribution of English score by race. It will be created by using functions provided by ggdist and ggplot2 packages.\n\n\nFirst, we will plot a Half-Eye graph by using stat_halfeye() of ggdist package.\nThis produces a Half Eye visualization, which is contains a half-density and a slab-interval.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA)\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\nWe remove the slab interval by setting .width = 0 and point_colour = NA.\n\n\n\n\n\n\n\n\nNext, we will add the second geometry layer using geom_boxplot() of ggplot2. This produces a narrow boxplot. We reduce the width and adjust the opacity.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA) +\n  geom_boxplot(width = .20,\n               outlier.shape = NA)\n\n\n\n\n\n\n\nNext, we will add the third geometry layer using stat_dots() of ggdist package. This produces a half-dotplot, which is similar to a histogram that indicates the number of samples (number of dots) in each bin. We select side = “left” to indicate we want it on the left-hand side.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA) +\n  geom_boxplot(width = .20,\n               outlier.shape = NA) +\n  stat_dots(side = \"left\", \n            justification = 1.2, \n            binwidth = .5,\n            dotsize = 2)\n\n\n\n\n\n\n\nLastly, coord_flip() of ggplot2 package will be used to flip the raincloud chart horizontally to give it the raincloud appearance. At the same time, theme_economist() of ggthemes package is used to give the raincloud chart a professional publishing standard look.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA) +\n  geom_boxplot(width = .20,\n               outlier.shape = NA) +\n  stat_dots(side = \"left\", \n            justification = 1.2, \n            binwidth = .5,\n            dotsize = 1.5) +\n  coord_flip() +\n  theme_economist()\n\n\n\n\n\n\n\n\n\nIntroducing Ridgeline Plots (formerly Joyplots)\nClaus O. Wilke Fundamentals of Data Visualization especially Chapter 6, 7, 8, 9 and 10.\nAllen M, Poggiali D, Whitaker K et al. “Raincloud plots: a multi-platform tool for robust data. visualization” [version 2; peer review: 2 approved]. Welcome Open Res 2021, pp. 4:63.\nDots + interval stats and geoms"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html#learning-outcome",
    "href": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html#learning-outcome",
    "title": "Hands-on Exercise 04A",
    "section": "",
    "text": "Visualizing distribution is not new in statistical analysis. In chapter 1 we have shared with you some of the popular statistical graphics methods for visualizing distribution are histogram, probability density curve (pdf), boxplot, notch plot and violin plot and how they can be created by using ggplot2. In this chapter, we are going to share with you two relatively new statistical graphic methods for visualizing distribution, namely ridgeline plot and raincloud plot by using ggplot2 and its extensions."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html#getting-started",
    "title": "Hands-on Exercise 04A",
    "section": "",
    "text": "For the purpose of this exercise, the following R packages will be used, they are:\n\nggridges, a ggplot2 extension specially designed for plotting ridgeline plots,\nggdist, a ggplot2 extension spacially desgin for visualizing distribution and uncertainty,\ntidyverse, a family of R packages to meet the modern data science and visual communication needs,\nggthemes, a ggplot extension that provides the user additional themes, scales, and geoms for the ggplots package, and\ncolorspace, an R package provides a broad toolbox for selecting individual colors or color palettes, manipulating these colors, and employing them in various kinds of visualizations.\n\nThe code chunk below will be used load these R packages into RStudio environment.\n\npacman::p_load(ggdist, ggridges, ggthemes,\n               colorspace, tidyverse)\n\n\n\n\nFor the purpose of this exercise, Exam_data.csv will be used.\nIn the code chunk below, read_csv() of readr package is used to import Exam_data.csv into R and saved it into a tibble data.frame.\n\nexam &lt;- read_csv(\"data/Exam_data.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html#visualizing-distribution-with-ridgeline-plot",
    "href": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html#visualizing-distribution-with-ridgeline-plot",
    "title": "Hands-on Exercise 04A",
    "section": "",
    "text": "Ridgeline plot (sometimes called Joyplot) is a data visualization technique for revealing the distribution of a numeric value for several groups. Distribution can be represented using histograms or density plots, all aligned to the same horizontal scale and presented with a slight overlap.\nFigure below is a ridgelines plot showing the distribution of English score by class.\n\n# Load libraries\nlibrary(ggplot2)\nlibrary(ggridges)\n\n# Plot\nggplot(exam, aes(x = ENGLISH, y = CLASS)) +\n  geom_density_ridges(\n    scale = 1.2,\n    rel_min_height = 0.01,\n    fill = \"gray\",\n    color = \"black\"\n  ) +\n  scale_x_continuous(\n    name = \"ENGLISH\",\n    expand = c(0, 0)\n  ) +\n  scale_y_discrete(\n    name = \"CLASS\",\n    expand = expansion(add = c(0.2, 0.5))\n  ) +\n  theme_minimal(base_size = 14) +  # Clean base theme\n  theme(\n    panel.grid.major.x = element_line(color =\"whitesmoke\"),  # vertical lines\n    panel.grid.major.y = element_line(color = \"whitesmoke\"),  # horizontal lines\n    panel.grid.minor = element_blank(),                   # no minor gridlines\n    panel.background = element_rect(fill = \"white\", color = NA),  # white background\n    plot.background = element_rect(fill = \"white\", color = NA)\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nRidgeline plots make sense when the number of groups to represent is medium to high. A classic window separation would take up too much space. The overlapping design of ridgelines makes better use of space. If you have fewer than 5 groups, other distribution plots may be more effective.\nRidgeline plots work well when there’s a clear pattern or ranking among groups. Otherwise, excessive overlap may lead to a messy plot with little insight.\n\n\n\n\n\nThere are several ways to plot ridgeline plot with R. In this section, you will learn how to plot ridgeline plot by using ggridges package.\nggridges package provides two main geom to plot gridgeline plots, they are: geom_ridgeline() and geom_density_ridges(). The former takes height values directly to draw the ridgelines, and the latter first estimates data densities and then draws those using ridgelines.\nThe ridgeline plot below is plotted by using geom_density_ridges().\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = ENGLISH, \n           y = CLASS)) +\n  geom_density_ridges(\n    scale = 3,\n    rel_min_height = 0.01,\n    bandwidth = 3.4,\n    fill = lighten(\"#7097BB\", .3),\n    color = \"white\"\n  ) +\n  scale_x_continuous(\n    name = \"English grades\",\n    expand = c(0, 0)\n    ) +\n  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +\n  theme_ridges()\n\n\n\n\n\n\n\nSometimes we would like to have the area under a ridgeline not filled with a single solid color but rather with colors that vary in some form along the x axis. This effect can be achieved by using either geom_ridgeline_gradient() or geom_density_ridges_gradient(). Both geoms work just like geom_ridgeline() and geom_density_ridges(), except that they allow for varying fill colors. However, they do not allow for alpha transparency in the fill. For technical reasons, we can have changing fill colors or transparency but not both.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = ENGLISH, \n           y = CLASS,\n           fill = stat(x))) +\n  geom_density_ridges_gradient(\n    scale = 3,\n    rel_min_height = 0.01) +\n  scale_fill_viridis_c(name = \"Temp. [F]\",\n                       option = \"C\") +\n  scale_x_continuous(\n    name = \"English grades\",\n    expand = c(0, 0)\n  ) +\n  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +\n  theme_ridges()\n\n\n\n\n\n\n\nBeside providing additional geom objects to support the need to plot ridgeline plot, ggridges package also provides a stat function called stat_density_ridges() that replaces stat_density() of ggplot2.\nFigure below is plotted by mapping the probabilities calculated by using stat(ecdf) which represent the empirical cumulative density function for the distribution of English score.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam,\n       aes(x = ENGLISH, \n           y = CLASS, \n           fill = 0.5 - abs(0.5-stat(ecdf)))) +\n  stat_density_ridges(geom = \"density_ridges_gradient\", \n                      calc_ecdf = TRUE) +\n  scale_fill_viridis_c(name = \"Tail probability\",\n                       direction = -1) +\n  theme_ridges()\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nIt is important to include the argument calc_ecdf = TRUE in stat_density_ridges().\n\n\n\n\n\nBy using geom_density_ridges_gradient(), we can colour the ridgeline plot by quantile, via the calculated stat(quantile) aesthetic as shown in the figure below.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam,\n       aes(x = ENGLISH, \n           y = CLASS, \n           fill = factor(stat(quantile))\n           )) +\n  stat_density_ridges(\n    geom = \"density_ridges_gradient\",\n    calc_ecdf = TRUE, \n    quantiles = 4,\n    quantile_lines = TRUE) +\n  scale_fill_viridis_d(name = \"Quartiles\") +\n  theme_ridges()\n\n\n\n\nInstead of using number to define the quantiles, we can also specify quantiles by cut points such as 2.5% and 97.5% tails to colour the ridgeline plot as shown in the figure below.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam,\n       aes(x = ENGLISH, \n           y = CLASS, \n           fill = factor(stat(quantile))\n           )) +\n  stat_density_ridges(\n    geom = \"density_ridges_gradient\",\n    calc_ecdf = TRUE, \n    quantiles = c(0.025, 0.975)\n    ) +\n  scale_fill_manual(\n    name = \"Probability\",\n    values = c(\"#FF0000A0\", \"#A0A0A0A0\", \"#0000FFA0\"),\n    labels = c(\"(0, 0.025]\", \"(0.025, 0.975]\", \"(0.975, 1]\")\n  ) +\n  theme_ridges()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html#visualizing-distribution-with-raincloud-plot",
    "href": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html#visualizing-distribution-with-raincloud-plot",
    "title": "Hands-on Exercise 04A",
    "section": "",
    "text": "Raincloud Plot is a data visualization techniques that produces a half-density to a distribution plot. It gets the name because the density plot is in the shape of a “raincloud”. The raincloud (half-density) plot enhances the traditional box-plot by highlighting multiple modalities (an indicator that groups may exist). The boxplot does not show where densities are clustered, but the raincloud plot does!\nIn this section, you will learn how to create a raincloud plot to visualize the distribution of English score by race. It will be created by using functions provided by ggdist and ggplot2 packages.\n\n\nFirst, we will plot a Half-Eye graph by using stat_halfeye() of ggdist package.\nThis produces a Half Eye visualization, which is contains a half-density and a slab-interval.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA)\n\n\n\n\n\n\n\nThings to learn from the code chunk above\n\n\n\nWe remove the slab interval by setting .width = 0 and point_colour = NA.\n\n\n\n\n\n\n\n\nNext, we will add the second geometry layer using geom_boxplot() of ggplot2. This produces a narrow boxplot. We reduce the width and adjust the opacity.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA) +\n  geom_boxplot(width = .20,\n               outlier.shape = NA)\n\n\n\n\n\n\n\nNext, we will add the third geometry layer using stat_dots() of ggdist package. This produces a half-dotplot, which is similar to a histogram that indicates the number of samples (number of dots) in each bin. We select side = “left” to indicate we want it on the left-hand side.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA) +\n  geom_boxplot(width = .20,\n               outlier.shape = NA) +\n  stat_dots(side = \"left\", \n            justification = 1.2, \n            binwidth = .5,\n            dotsize = 2)\n\n\n\n\n\n\n\nLastly, coord_flip() of ggplot2 package will be used to flip the raincloud chart horizontally to give it the raincloud appearance. At the same time, theme_economist() of ggthemes package is used to give the raincloud chart a professional publishing standard look.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA) +\n  geom_boxplot(width = .20,\n               outlier.shape = NA) +\n  stat_dots(side = \"left\", \n            justification = 1.2, \n            binwidth = .5,\n            dotsize = 1.5) +\n  coord_flip() +\n  theme_economist()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html#references",
    "href": "Hands-on_Ex/Hands-on_Ex04A/Hands-on_Ex04A.html#references",
    "title": "Hands-on Exercise 04A",
    "section": "",
    "text": "Introducing Ridgeline Plots (formerly Joyplots)\nClaus O. Wilke Fundamentals of Data Visualization especially Chapter 6, 7, 8, 9 and 10.\nAllen M, Poggiali D, Whitaker K et al. “Raincloud plots: a multi-platform tool for robust data. visualization” [version 2; peer review: 2 approved]. Welcome Open Res 2021, pp. 4:63.\nDots + interval stats and geoms"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04B/Hands-on_Ex04B.html",
    "href": "Hands-on_Ex/Hands-on_Ex04B/Hands-on_Ex04B.html",
    "title": "Hands-on Exercise 04B",
    "section": "",
    "text": "In this hands-on exercise, we will gain hands-on experience on using:\n\nggstatsplot package to create visual graphics with rich statistical information,\nperformance package to visualise model diagnostics, and\nparameters package to visualise model parameters\n\n\n\n\nggstatsplot  is an extension of ggplot2 package for creating graphics with details from statistical tests included in the information-rich plots themselves.\n\nTo provide alternative statistical inference methods by default.\nTo follow best practices for statistical reporting. For all statistical tests reported in the plots, the default template abides by the [APA](https://my.ilstu.edu/~jhkahn/apastats.html) gold standard for statistical reporting. For example, here are results from a robust t-test:\n\n\n\n\n\n\n\nIn this exercise, ggstatsplot and tidyverse will be used.\n\npacman::p_load(ggstatsplot, tidyverse)\n\n\n\n\n\nexam &lt;- read_csv(\"data/Exam_data.csv\")\n\n\n\n\n\n\n\nDo-It-Yourself\n\n\n\nImporting Exam.csv data by using appropriate tidyverse package.\n\n\n# A tibble: 322 × 7 ID CLASS GENDER RACE ENGLISH MATHS SCIENCE &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Student321 3I Male Malay 21 9 15 2 Student305 3I Female Malay 24 22 16 3 Student289 3H Male Chinese 26 16 16 4 Student227 3F Male Chinese 27 77 31 5 Student318 3I Male Malay 27 11 25 6 Student306 3I Female Malay 31 16 16 7 Student313 3I Male Chinese 31 21 25 8 Student316 3I Male Malay 31 18 27 9 Student312 3I Male Malay 33 19 15 10 Student297 3H Male Indian 34 49 37 # ℹ 312 more rows\n\n\n\nIn the code chunk below, gghistostats() is used to to build an visual of one-sample test on English scores.\n\nset.seed(1234)\n\ngghistostats(\n  data = exam,\n  x = ENGLISH,\n  type = \"bayes\",\n  test.value = 60,\n  xlab = \"English scores\"\n)\n\n\n\n\n\n\n\n\nDefault information: - statistical details - Bayes Factor - sample sizes - distribution summary\n\n\n\n\nA Bayes factor is the ratio of the likelihood of one particular hypothesis to the likelihood of another. It can be interpreted as a measure of the strength of evidence in favor of one theory among two competing theories.\nThat’s because the Bayes factor gives us a way to evaluate the data in favor of a null hypothesis, and to use external information to do so. It tells us what the weight of the evidence is in favor of a given hypothesis.\nWhen we are comparing two hypotheses, H1 (the alternate hypothesis) and H0 (the null hypothesis), the Bayes Factor is often written as B10. It can be defined mathematically as\n\n\n\n\nThe Schwarz criterion is one of the easiest ways to calculate rough approximation of the Bayes Factor.\n\n\n\n\nA Bayes Factor can be any positive number. One of the most common interpretations is this one—first proposed by Harold Jeffereys (1961) and slightly modified by Lee and Wagenmakers in 2013:\n\n\n\n\nIn the code chunk below, ggbetweenstats() is used to build a visual for two-sample mean test of Maths scores by gender.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggbetweenstats(\n  data = exam,\n  x = GENDER, \n  y = MATHS,\n  type = \"np\",\n  messages = FALSE\n)\n\n\n\n\nDefault information: - statistical details - Bayes Factor - sample sizes - distribution summary\n\n\n\nIn the code chunk below, ggbetweenstats() is used to build a visual for One-way ANOVA test on English score by race.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggbetweenstats(\n  data = exam,\n  x = RACE, \n  y = ENGLISH,\n  type = \"p\",\n  mean.ci = TRUE, \n  pairwise.comparisons = TRUE, \n  pairwise.display = \"s\",\n  p.adjust.method = \"fdr\",\n  messages = FALSE\n)\n\n\n\n\n\n“ns” → only non-significant\n“s” → only significant\n“all” → everything\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the code chunk below, ggscatterstats() is used to build a visual for Significant Test of Correlation between Maths scores and English scores.\n\nggscatterstats(\n  data = exam,\n  x = MATHS,\n  y = ENGLISH,\n  marginal = FALSE,\n  )\n\n\n\n\n\n\n\n\n\n\n\nIn the code chunk below, the Maths scores is binned into a 4-class variable by using cut().\n\nexam1 &lt;- exam %&gt;% \n  mutate(MATHS_bins = \n           cut(MATHS, \n               breaks = c(0,60,75,85,100))\n)\n\nIn this code chunk below ggbarstats() is used to build a visual for Significant Test of Association\n\nggbarstats(exam1, \n           x = MATHS_bins, \n           y = GENDER)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04B/Hands-on_Ex04B.html#learning-outcome",
    "href": "Hands-on_Ex/Hands-on_Ex04B/Hands-on_Ex04B.html#learning-outcome",
    "title": "Hands-on Exercise 04B",
    "section": "",
    "text": "In this hands-on exercise, we will gain hands-on experience on using:\n\nggstatsplot package to create visual graphics with rich statistical information,\nperformance package to visualise model diagnostics, and\nparameters package to visualise model parameters"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04B/Hands-on_Ex04B.html#visual-statistical-analysis-with-ggstatsplot",
    "href": "Hands-on_Ex/Hands-on_Ex04B/Hands-on_Ex04B.html#visual-statistical-analysis-with-ggstatsplot",
    "title": "Hands-on Exercise 04B",
    "section": "",
    "text": "ggstatsplot  is an extension of ggplot2 package for creating graphics with details from statistical tests included in the information-rich plots themselves.\n\nTo provide alternative statistical inference methods by default.\nTo follow best practices for statistical reporting. For all statistical tests reported in the plots, the default template abides by the [APA](https://my.ilstu.edu/~jhkahn/apastats.html) gold standard for statistical reporting. For example, here are results from a robust t-test:"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04B/Hands-on_Ex04B.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex04B/Hands-on_Ex04B.html#getting-started",
    "title": "Hands-on Exercise 04B",
    "section": "",
    "text": "In this exercise, ggstatsplot and tidyverse will be used.\n\npacman::p_load(ggstatsplot, tidyverse)\n\n\n\n\n\nexam &lt;- read_csv(\"data/Exam_data.csv\")\n\n\n\n\n\n\n\nDo-It-Yourself\n\n\n\nImporting Exam.csv data by using appropriate tidyverse package.\n\n\n# A tibble: 322 × 7 ID CLASS GENDER RACE ENGLISH MATHS SCIENCE &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Student321 3I Male Malay 21 9 15 2 Student305 3I Female Malay 24 22 16 3 Student289 3H Male Chinese 26 16 16 4 Student227 3F Male Chinese 27 77 31 5 Student318 3I Male Malay 27 11 25 6 Student306 3I Female Malay 31 16 16 7 Student313 3I Male Chinese 31 21 25 8 Student316 3I Male Malay 31 18 27 9 Student312 3I Male Malay 33 19 15 10 Student297 3H Male Indian 34 49 37 # ℹ 312 more rows\n\n\n\nIn the code chunk below, gghistostats() is used to to build an visual of one-sample test on English scores.\n\nset.seed(1234)\n\ngghistostats(\n  data = exam,\n  x = ENGLISH,\n  type = \"bayes\",\n  test.value = 60,\n  xlab = \"English scores\"\n)\n\n\n\n\n\n\n\n\nDefault information: - statistical details - Bayes Factor - sample sizes - distribution summary\n\n\n\n\nA Bayes factor is the ratio of the likelihood of one particular hypothesis to the likelihood of another. It can be interpreted as a measure of the strength of evidence in favor of one theory among two competing theories.\nThat’s because the Bayes factor gives us a way to evaluate the data in favor of a null hypothesis, and to use external information to do so. It tells us what the weight of the evidence is in favor of a given hypothesis.\nWhen we are comparing two hypotheses, H1 (the alternate hypothesis) and H0 (the null hypothesis), the Bayes Factor is often written as B10. It can be defined mathematically as\n\n\n\n\nThe Schwarz criterion is one of the easiest ways to calculate rough approximation of the Bayes Factor.\n\n\n\n\nA Bayes Factor can be any positive number. One of the most common interpretations is this one—first proposed by Harold Jeffereys (1961) and slightly modified by Lee and Wagenmakers in 2013:\n\n\n\n\nIn the code chunk below, ggbetweenstats() is used to build a visual for two-sample mean test of Maths scores by gender.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggbetweenstats(\n  data = exam,\n  x = GENDER, \n  y = MATHS,\n  type = \"np\",\n  messages = FALSE\n)\n\n\n\n\nDefault information: - statistical details - Bayes Factor - sample sizes - distribution summary\n\n\n\nIn the code chunk below, ggbetweenstats() is used to build a visual for One-way ANOVA test on English score by race.\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggbetweenstats(\n  data = exam,\n  x = RACE, \n  y = ENGLISH,\n  type = \"p\",\n  mean.ci = TRUE, \n  pairwise.comparisons = TRUE, \n  pairwise.display = \"s\",\n  p.adjust.method = \"fdr\",\n  messages = FALSE\n)\n\n\n\n\n\n“ns” → only non-significant\n“s” → only significant\n“all” → everything\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the code chunk below, ggscatterstats() is used to build a visual for Significant Test of Correlation between Maths scores and English scores.\n\nggscatterstats(\n  data = exam,\n  x = MATHS,\n  y = ENGLISH,\n  marginal = FALSE,\n  )\n\n\n\n\n\n\n\n\n\n\n\nIn the code chunk below, the Maths scores is binned into a 4-class variable by using cut().\n\nexam1 &lt;- exam %&gt;% \n  mutate(MATHS_bins = \n           cut(MATHS, \n               breaks = c(0,60,75,85,100))\n)\n\nIn this code chunk below ggbarstats() is used to build a visual for Significant Test of Association\n\nggbarstats(exam1, \n           x = MATHS_bins, \n           y = GENDER)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html",
    "href": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html",
    "title": "Hands-on Exercise 04D",
    "section": "",
    "text": "Funnel plot is a specially designed data visualisation for conducting unbiased comparison between outlets, stores or business entities. By the end of this hands-on exercise, we will gain hands-on experience on:\n\nplotting funnel plots by using funnelPlotR package,\nplotting static funnel plot by using ggplot2 package, and\nplotting interactive funnel plot by using both plotly R and ggplot2 packages.\n\n\n\n\nIn this exercise, four R packages will be used. They are:\n\nreadr for importing csv into R.\nFunnelPlotR for creating funnel plot.\nggplot2 for creating funnel plot manually.\nknitr for building static html table.\nplotly for creating interactive funnel plot.\n\n\npacman::p_load(tidyverse, FunnelPlotR, plotly, knitr)\n\n\n\n\nIn this section, COVID-19_DKI_Jakarta will be used. The data was downloaded from Open Data Covid-19 Provinsi DKI Jakarta portal. For this hands-on exercise, we are going to compare the cumulative COVID-19 cases and death by sub-district (i.e. kelurahan) as at 31st July 2021, DKI Jakarta.\nThe code chunk below imports the data into R and save it into a tibble data frame object called covid19.\n\ncovid19 &lt;- read_csv(\"data/COVID-19_DKI_Jakarta.csv\") %&gt;%\n  mutate_if(is.character, as.factor)\n\n\n\n\n\n\n\n\n\n\n\n\n\nSub-district ID\nCity\nDistrict\nSub-district\nPositive\nRecovered\nDeath\n\n\n\n\n3172051003\nJAKARTA UTARA\nPADEMANGAN\nANCOL\n1776\n1691\n26\n\n\n3173041007\nJAKARTA BARAT\nTAMBORA\nANGKE\n1783\n1720\n29\n\n\n3175041005\nJAKARTA TIMUR\nKRAMAT JATI\nBALE KAMBANG\n2049\n1964\n31\n\n\n3175031003\nJAKARTA TIMUR\nJATINEGARA\nBALI MESTER\n827\n797\n13\n\n\n3175101006\nJAKARTA TIMUR\nCIPAYUNG\nBAMBU APUS\n2866\n2792\n27\n\n\n3174031002\nJAKARTA SELATAN\nMAMPANG PRAPATAN\nBANGKA\n1828\n1757\n26\n\n\n\n\n\n\nFunnelPlotR package uses ggplot to generate funnel plots. It requires a numerator (events of interest), denominator (population to be considered) and group. The key arguments selected for customisation are:\n\nlimit: plot limits (95 or 99).\nlabel_outliers: to label outliers (true or false).\nPoisson_limits: to add Poisson limits to the plot.\nOD_adjust: to add overdispersed limits to the plot.\nxrange and yrange: to specify the range to display for axes, acts like a zoom function.\nOther aesthetic components such as graph title, axis labels etc.\n\n\n\nThe code chunk below plots a funnel plot.\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Positive,\n  denominator = Death,\n  group = `Sub-district`\n)\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 0 are outliers. \nPlot is adjusted for overdispersion. \n\n\nA funnel plot object with 267 points of which 0 are outliers.  Plot is adjusted for overdispersion. \nThings to learn from the code chunk above.\n\ngroup in this function is different from the scatterplot. Here, it defines the level of the points to be plotted i.e. Sub-district, District or City. If Cityc is chosen, there are only six data points.\nBy default, data_typeargument is “SR”.\nlimit: Plot limits, accepted values are: 95 or 99, corresponding to 95% or 99.8% quantiles of the distribution.\n\n\n\n\nThe code chunk below plots a funnel plot.\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Death,\n  denominator = Positive,\n  group = `Sub-district`,\n  data_type = \"PR\",     #&lt;&lt;\n  xrange = c(0, 6500),  #&lt;&lt;\n  yrange = c(0, 0.05)   #&lt;&lt;\n)\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion. \n\n\nA funnel plot object with 267 points of which 7 are outliers.  Plot is adjusted for overdispersion. \nThings to learn from the code chunk above. + data_type argument is used to change from default “SR” to “PR” (i.e. proportions). + xrange and yrange are used to set the range of x-axis and y-axis\n\n\n\nThe code chunk below plots a funnel plot.\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Death,\n  denominator = Positive,\n  group = `Sub-district`,\n  data_type = \"PR\",   \n  xrange = c(0, 6500),  \n  yrange = c(0, 0.05),\n  label = NA,\n  title = \"Cumulative COVID-19 Fatality Rate by Cumulative Total Number of COVID-19 Positive Cases\", #&lt;&lt;           \n  x_label = \"Cumulative COVID-19 Positive Cases\", #&lt;&lt;\n  y_label = \"Cumulative Fatality Rate\"  #&lt;&lt;\n)\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion. \n\n\nA funnel plot object with 267 points of which 7 are outliers.  Plot is adjusted for overdispersion. \nThings to learn from the code chunk above.\n\nlabel = NA argument is to removed the default label outliers feature.\ntitle argument is used to add plot title.\nx_label and y_label arguments are used to add/edit x-axis and y-axis titles.\n\n\n\n\n\nIn this section, you will gain hands-on experience on building funnel plots step-by-step by using ggplot2. It aims to enhance you working experience of ggplot2 to customise speciallised data visualization like funnel plot.\n\n\nTo plot the funnel plot from scratch, we need to derive cumulative death rate and standard error of cumulative death rate.\n\ndf &lt;- covid19 %&gt;%\n  mutate(rate = Death / Positive) %&gt;%\n  mutate(rate.se = sqrt((rate*(1-rate)) / (Positive))) %&gt;%\n  filter(rate &gt; 0)\n\nNext, the fit.mean is computed by using the code chunk below.\n\nfit.mean &lt;- weighted.mean(df$rate, 1/df$rate.se^2)\n\n\n\n\nThe code chunk below is used to compute the lower and upper limits for 95% confidence interval.\n\nnumber.seq &lt;- seq(1, max(df$Positive), 1)\nnumber.ll95 &lt;- fit.mean - 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ul95 &lt;- fit.mean + 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ll999 &lt;- fit.mean - 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ul999 &lt;- fit.mean + 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \ndfCI &lt;- data.frame(number.ll95, number.ul95, number.ll999, \n                   number.ul999, number.seq, fit.mean)\n\n\n\n\nIn the code chunk below, ggplot2 functions are used to plot a static funnel plot.\n\np &lt;- ggplot(df, aes(x = Positive, y = rate)) +\n  geom_point(aes(label=`Sub-district`), \n             alpha=0.4) +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ll95), \n            size = 0.4, \n            colour = \"grey40\", \n            linetype = \"dashed\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ul95), \n            size = 0.4, \n            colour = \"grey40\", \n            linetype = \"dashed\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ll999), \n            size = 0.4, \n            colour = \"grey40\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ul999), \n            size = 0.4, \n            colour = \"grey40\") +\n  geom_hline(data = dfCI, \n             aes(yintercept = fit.mean), \n             size = 0.4, \n             colour = \"grey40\") +\n  coord_cartesian(ylim=c(0,0.05)) +\n  annotate(\"text\", x = 1, y = -0.13, label = \"95%\", size = 3, colour = \"grey40\") + \n  annotate(\"text\", x = 4.5, y = -0.18, label = \"99%\", size = 3, colour = \"grey40\") + \n  ggtitle(\"Cumulative Fatality Rate by Cumulative Number of COVID-19 Cases\") +\n  xlab(\"Cumulative Number of COVID-19 Cases\") + \n  ylab(\"Cumulative Fatality Rate\") +\n  theme_light() +\n  theme(plot.title = element_text(size=12),\n        legend.position = c(0.91,0.85), \n        legend.title = element_text(size=7),\n        legend.text = element_text(size=7),\n        legend.background = element_rect(colour = \"grey60\", linetype = \"dotted\"),\n        legend.key.height = unit(0.3, \"cm\"))\np\n\n\n\n\n\n\n\n\n\n\n\nThe funnel plot created using ggplot2 functions can be made interactive with ggplotly() of plotly r package.\n\nfp_ggplotly &lt;- ggplotly(p,\n  tooltip = c(\"label\", \n              \"x\", \n              \"y\"))\nfp_ggplotly\n\n\n\n\n\n\n\n\n\n\nfunnelPlotR package.\nFunnel Plots for Indirectly-standardised ratios.\nChanging funnel plot options\nggplot2 package."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#overview",
    "href": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#overview",
    "title": "Hands-on Exercise 04D",
    "section": "",
    "text": "Funnel plot is a specially designed data visualisation for conducting unbiased comparison between outlets, stores or business entities. By the end of this hands-on exercise, we will gain hands-on experience on:\n\nplotting funnel plots by using funnelPlotR package,\nplotting static funnel plot by using ggplot2 package, and\nplotting interactive funnel plot by using both plotly R and ggplot2 packages."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#installing-and-launching-r-packages",
    "href": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#installing-and-launching-r-packages",
    "title": "Hands-on Exercise 04D",
    "section": "",
    "text": "In this exercise, four R packages will be used. They are:\n\nreadr for importing csv into R.\nFunnelPlotR for creating funnel plot.\nggplot2 for creating funnel plot manually.\nknitr for building static html table.\nplotly for creating interactive funnel plot.\n\n\npacman::p_load(tidyverse, FunnelPlotR, plotly, knitr)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#importing-data",
    "href": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#importing-data",
    "title": "Hands-on Exercise 04D",
    "section": "",
    "text": "In this section, COVID-19_DKI_Jakarta will be used. The data was downloaded from Open Data Covid-19 Provinsi DKI Jakarta portal. For this hands-on exercise, we are going to compare the cumulative COVID-19 cases and death by sub-district (i.e. kelurahan) as at 31st July 2021, DKI Jakarta.\nThe code chunk below imports the data into R and save it into a tibble data frame object called covid19.\n\ncovid19 &lt;- read_csv(\"data/COVID-19_DKI_Jakarta.csv\") %&gt;%\n  mutate_if(is.character, as.factor)\n\n\n\n\n\n\n\n\n\n\n\n\n\nSub-district ID\nCity\nDistrict\nSub-district\nPositive\nRecovered\nDeath\n\n\n\n\n3172051003\nJAKARTA UTARA\nPADEMANGAN\nANCOL\n1776\n1691\n26\n\n\n3173041007\nJAKARTA BARAT\nTAMBORA\nANGKE\n1783\n1720\n29\n\n\n3175041005\nJAKARTA TIMUR\nKRAMAT JATI\nBALE KAMBANG\n2049\n1964\n31\n\n\n3175031003\nJAKARTA TIMUR\nJATINEGARA\nBALI MESTER\n827\n797\n13\n\n\n3175101006\nJAKARTA TIMUR\nCIPAYUNG\nBAMBU APUS\n2866\n2792\n27\n\n\n3174031002\nJAKARTA SELATAN\nMAMPANG PRAPATAN\nBANGKA\n1828\n1757\n26"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#funnelplotr-methods",
    "href": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#funnelplotr-methods",
    "title": "Hands-on Exercise 04D",
    "section": "",
    "text": "FunnelPlotR package uses ggplot to generate funnel plots. It requires a numerator (events of interest), denominator (population to be considered) and group. The key arguments selected for customisation are:\n\nlimit: plot limits (95 or 99).\nlabel_outliers: to label outliers (true or false).\nPoisson_limits: to add Poisson limits to the plot.\nOD_adjust: to add overdispersed limits to the plot.\nxrange and yrange: to specify the range to display for axes, acts like a zoom function.\nOther aesthetic components such as graph title, axis labels etc.\n\n\n\nThe code chunk below plots a funnel plot.\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Positive,\n  denominator = Death,\n  group = `Sub-district`\n)\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 0 are outliers. \nPlot is adjusted for overdispersion. \n\n\nA funnel plot object with 267 points of which 0 are outliers.  Plot is adjusted for overdispersion. \nThings to learn from the code chunk above.\n\ngroup in this function is different from the scatterplot. Here, it defines the level of the points to be plotted i.e. Sub-district, District or City. If Cityc is chosen, there are only six data points.\nBy default, data_typeargument is “SR”.\nlimit: Plot limits, accepted values are: 95 or 99, corresponding to 95% or 99.8% quantiles of the distribution.\n\n\n\n\nThe code chunk below plots a funnel plot.\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Death,\n  denominator = Positive,\n  group = `Sub-district`,\n  data_type = \"PR\",     #&lt;&lt;\n  xrange = c(0, 6500),  #&lt;&lt;\n  yrange = c(0, 0.05)   #&lt;&lt;\n)\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion. \n\n\nA funnel plot object with 267 points of which 7 are outliers.  Plot is adjusted for overdispersion. \nThings to learn from the code chunk above. + data_type argument is used to change from default “SR” to “PR” (i.e. proportions). + xrange and yrange are used to set the range of x-axis and y-axis\n\n\n\nThe code chunk below plots a funnel plot.\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Death,\n  denominator = Positive,\n  group = `Sub-district`,\n  data_type = \"PR\",   \n  xrange = c(0, 6500),  \n  yrange = c(0, 0.05),\n  label = NA,\n  title = \"Cumulative COVID-19 Fatality Rate by Cumulative Total Number of COVID-19 Positive Cases\", #&lt;&lt;           \n  x_label = \"Cumulative COVID-19 Positive Cases\", #&lt;&lt;\n  y_label = \"Cumulative Fatality Rate\"  #&lt;&lt;\n)\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion. \n\n\nA funnel plot object with 267 points of which 7 are outliers.  Plot is adjusted for overdispersion. \nThings to learn from the code chunk above.\n\nlabel = NA argument is to removed the default label outliers feature.\ntitle argument is used to add plot title.\nx_label and y_label arguments are used to add/edit x-axis and y-axis titles."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#funnel-plot-for-fair-visual-comparison-ggplot2-methods",
    "href": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#funnel-plot-for-fair-visual-comparison-ggplot2-methods",
    "title": "Hands-on Exercise 04D",
    "section": "",
    "text": "In this section, you will gain hands-on experience on building funnel plots step-by-step by using ggplot2. It aims to enhance you working experience of ggplot2 to customise speciallised data visualization like funnel plot.\n\n\nTo plot the funnel plot from scratch, we need to derive cumulative death rate and standard error of cumulative death rate.\n\ndf &lt;- covid19 %&gt;%\n  mutate(rate = Death / Positive) %&gt;%\n  mutate(rate.se = sqrt((rate*(1-rate)) / (Positive))) %&gt;%\n  filter(rate &gt; 0)\n\nNext, the fit.mean is computed by using the code chunk below.\n\nfit.mean &lt;- weighted.mean(df$rate, 1/df$rate.se^2)\n\n\n\n\nThe code chunk below is used to compute the lower and upper limits for 95% confidence interval.\n\nnumber.seq &lt;- seq(1, max(df$Positive), 1)\nnumber.ll95 &lt;- fit.mean - 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ul95 &lt;- fit.mean + 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ll999 &lt;- fit.mean - 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ul999 &lt;- fit.mean + 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \ndfCI &lt;- data.frame(number.ll95, number.ul95, number.ll999, \n                   number.ul999, number.seq, fit.mean)\n\n\n\n\nIn the code chunk below, ggplot2 functions are used to plot a static funnel plot.\n\np &lt;- ggplot(df, aes(x = Positive, y = rate)) +\n  geom_point(aes(label=`Sub-district`), \n             alpha=0.4) +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ll95), \n            size = 0.4, \n            colour = \"grey40\", \n            linetype = \"dashed\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ul95), \n            size = 0.4, \n            colour = \"grey40\", \n            linetype = \"dashed\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ll999), \n            size = 0.4, \n            colour = \"grey40\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ul999), \n            size = 0.4, \n            colour = \"grey40\") +\n  geom_hline(data = dfCI, \n             aes(yintercept = fit.mean), \n             size = 0.4, \n             colour = \"grey40\") +\n  coord_cartesian(ylim=c(0,0.05)) +\n  annotate(\"text\", x = 1, y = -0.13, label = \"95%\", size = 3, colour = \"grey40\") + \n  annotate(\"text\", x = 4.5, y = -0.18, label = \"99%\", size = 3, colour = \"grey40\") + \n  ggtitle(\"Cumulative Fatality Rate by Cumulative Number of COVID-19 Cases\") +\n  xlab(\"Cumulative Number of COVID-19 Cases\") + \n  ylab(\"Cumulative Fatality Rate\") +\n  theme_light() +\n  theme(plot.title = element_text(size=12),\n        legend.position = c(0.91,0.85), \n        legend.title = element_text(size=7),\n        legend.text = element_text(size=7),\n        legend.background = element_rect(colour = \"grey60\", linetype = \"dotted\"),\n        legend.key.height = unit(0.3, \"cm\"))\np\n\n\n\n\n\n\n\n\n\n\n\nThe funnel plot created using ggplot2 functions can be made interactive with ggplotly() of plotly r package.\n\nfp_ggplotly &lt;- ggplotly(p,\n  tooltip = c(\"label\", \n              \"x\", \n              \"y\"))\nfp_ggplotly"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#references",
    "href": "Hands-on_Ex/Hands-on_Ex04D/Hands-on_Ex04D.html#references",
    "title": "Hands-on Exercise 04D",
    "section": "",
    "text": "funnelPlotR package.\nFunnel Plots for Indirectly-standardised ratios.\nChanging funnel plot options\nggplot2 package."
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex_05/MC1.html",
    "href": "In-Class_Ex/In-Class_Ex_05/MC1.html",
    "title": "In-Class Exercise 05",
    "section": "",
    "text": "MC 01\npacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph)\nkg &lt;- fromJSON(\"data/MC1_graph.json\")"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex_05/MC1.html#initial-eda",
    "href": "In-Class_Ex/In-Class_Ex_05/MC1.html#initial-eda",
    "title": "In-Class Exercise 05",
    "section": "Initial EDA",
    "text": "Initial EDA\n\nggplot(data = edges_tbl, aes(y = `Edge Type`)) + \n  geom_bar()"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex_05/MC1.html#creating-knowledge-graph",
    "href": "In-Class_Ex/In-Class_Ex_05/MC1.html#creating-knowledge-graph",
    "title": "In-Class Exercise 05",
    "section": "Creating knowledge graph",
    "text": "Creating knowledge graph\n\nStep 1: Mapping from node id to row index\n\nid_map &lt;- tibble(id = nodes_tbl$id, index = seq_len(nrow(nodes_tbl)))\n\n\n\nStep 2: Map source and target IDs to row indices\n\nedges_tbl &lt;- edges_tbl %&gt;%\n  left_join(id_map, by = c(\"source\" = \"id\"), suffix = c(\"\", \"_source\")) %&gt;%\n  rename(from = index) %&gt;%\n  left_join(id_map, by = c(\"target\" = \"id\"), suffix = c(\"\", \"_target\")) %&gt;%\n  rename(to = index)\n\n\n\nStep 3\n\nedges_tbl &lt;- edges_tbl %&gt;%\n  filter(!is.na(from), !is.na(to))\n\n\n\nStep 4: Creating the graph\n\ngraph &lt;- tbl_graph(nodes = nodes_tbl, edges = edges_tbl, \n                   directed = kg$directed)"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex_05/MC1.html#visualizing-the-knowledge-graph",
    "href": "In-Class_Ex/In-Class_Ex_05/MC1.html#visualizing-the-knowledge-graph",
    "title": "In-Class Exercise 05",
    "section": "Visualizing the knowledge graph",
    "text": "Visualizing the knowledge graph\n\nset.seed(1234)\n\n\nVisualizing the whole Graph\n\nggraph(graph, layout = \"fr\") + \n  geom_edge_link(alpha = 0.3, colour = \"gray\") +\n  geom_node_point(aes(color = `Node Type`), size = 4) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 2.5) +\n  theme_void()\n\n\nStep 1: Filter edges to only “MemberOf”\n\ngraph_memberof &lt;- graph %&gt;%\n  activate(edges) %&gt;%\n  filter(`Edge Type` == \"MemberOf\")\n\n\n\nStep 2: Extract only connected nodes (ie. used in these edges)\n\nused_node_indices &lt;- graph_memberof %&gt;%\n  activate(edges) %&gt;%\n  as_tibble() %&gt;%\n  select(from, to) %&gt;%\n  unlist() %&gt;%\n  unique()\n\n\n\nStep 3: Keep only those nodes\n\ngraph_memberof &lt;- graph_memberof %&gt;%\n  activate(nodes) %&gt;%\n  mutate(row_id = row_number()) %&gt;%\n  filter(row_id %in% used_node_indices) %&gt;%\n  select(-row_id)  #optional cleanup\n\n\n\nPlot the sub-graph\n\nggraph(graph_memberof, layout = \"fr\") + \n  geom_edge_link(alpha = 0.5, colour = \"gray\") +\n  geom_node_point(aes(color = `Node Type`), size = 1) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 2.5) +\n  theme_void()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Creating enlightening and truthful data visualizations involves focusing on accuracy, transparency, and the ability to effectively communicate insights. It’s about presenting data in a way that is both informative and aesthetically pleasing, ensuring the audience can grasp the information quickly and accurately.\n\n\n\nA local online media company that publishes daily content on digital platforms is planning to release an article on demographic structures and distribution of Singapore in 2024.\n\n\n\nAssuming the role of the graphical editor of the media company, we are tasked to prepare at most three data visualization for the article.\n\n\n\n\n\nWe load the following R packages using the pacman::p_load() function:\n\ntidyverse: R packages designed for data science\nggrepel: to provides geoms for ggplot2 to repel overlapping text labels\nggthemes: to use additional themes for ggplot2\npatchwork: to prepare composite figure created using ggplot2\nscales: to provide the internal scaling infrastructure used by ggplot2\nggpubr to create publication ready ggplot2 plots.\n\nThe code chunk below uses the p_load() function in the pacman package to check if the packages are installed in the computer.\n\npacman::p_load(tidyverse, ggrepel, patchwork, ggthemes, scales,\n               ggpubr) \n\n\n\n\nTo accomplish the task, Singapore Residents by Planning Area / Subzone, Single Year of Age and Sex, June 2024 dataset shared by Department of Statistics, Singapore (DOS) will be used and we wil load it as follows:\n\ndata &lt;- read_csv(\"data/respopagesex2024.csv\", col_names = TRUE)\n\n\n\n\n\n\nWe first take a look at the data. Using the code below, we can get the details of the dataset which contains 60,424 rows and 6 columns.\n\nglimpse(data)\n\nRows: 60,424\nColumns: 6\n$ PA   &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo K…\n$ SZ   &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Centre\", \"Ang Mo Kio T…\n$ Age  &lt;chr&gt; \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", \"4\", \"4\", \"5\", \"5\", \"6\", …\n$ Sex  &lt;chr&gt; \"Males\", \"Females\", \"Males\", \"Females\", \"Males\", \"Females\", \"Male…\n$ Pop  &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 30, 10, 20, 10, 20, 30, 30, 10, 3…\n$ Time &lt;dbl&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024,…\n\n\n\n\n\n\nWe notice that there is only one value in Time column (2024) which will not be used for further analysis, we will delete this column as per the code chunk below:\n\n\ndata &lt;- data %&gt;% select(-Time)\n\n\nWe will rename the column names in the dataset for clarity, as detailed provided by the Department of Statistics (DOS), as follows:\n\nPA → Planning Area\nSZ → Subzone\nPop → Resident Count\n\n\n\n\n\n\nSide Note:\n\n\n\nPlease note: according to the DOS accompanying documentation of this dataset, the population figures in the csv file have been rounded to the nearest 10, and as such, total counts may not sum exactly due to rounding adjustments.\n\n\n\ncolnames(data) &lt;- c(\"PlanningArea\", \"SubZone\", \"Age\", \"Sex\", \"ResidentCount\")\n\n\nNext, we observe that for the Age column, there is a value of : “90_and_over”. We will replace this value with “90” and change the data type from string/character to numeric and then create a new column to classify the age according to the age bracket in the interval of 5 years as per the standard age group published in DOS:\n\n\ndata &lt;- data %&gt;%\n  mutate(\n    # Normalize Age values to lowercase\n    Age = str_to_lower(Age),\n    \n    # Replace \"90_and_over\" with \"90\"\n    Age = ifelse(Age == \"90_and_over\", \"90\", Age),\n    \n    # Convert to numeric\n    Age = as.numeric(Age),\n    \n    # Create AgeGroup with standard bins\n    AgeGroup = cut(Age,\n                   breaks = c(0,4,9,14,19,24,29,34,39,44,49,54,59,64,69,74,79,84,89, Inf),\n                   labels = c(\"0–4\", \"5–9\", \"10–14\", \"15–19\", \"20–24\", \"25–29\",\n                              \"30–34\", \"35–39\", \"40–44\", \"45–49\", \"50–54\", \n                              \"55–59\", \"60–64\", \"65–69\", \"70–74\", \"75–79\", \n                              \"80–84\", \"85–89\", \"90+\"),\n                   right = TRUE, include.lowest = TRUE)\n  )\n\n\nFurther observation of the dataset, we discover there are multiple rows with “0” values in the “Pop”/“ResidentCount” column. We will remove these rows as per the code chunk below, and calculate the number of rows and total population before and after the deletion to ensure completeness:\n\n\n# Total population before removing zero-pop rows\ntotal_population_before &lt;- sum(data$ResidentCount, na.rm = TRUE)\ntotal_rows_before &lt;- nrow(data)\n\n# Count and show how many rows have 0 population\nzero_count &lt;- data %&gt;%\n  filter(ResidentCount == 0) %&gt;%\n  nrow()\n\ncat(\"Total population before cleaning:\", format(total_population_before, big.mark = \",\"), \"\\n\")\n\nTotal population before cleaning: 4,193,530 \n\ncat(\"Total rows before cleaning:\", total_rows_before, \"\\n\")\n\nTotal rows before cleaning: 60424 \n\ncat(\"Rows with 0 ResidentCount removed:\", zero_count, \"\\n\")\n\nRows with 0 ResidentCount removed: 23181 \n\n# Remove rows with 0 population\ndata &lt;- data %&gt;%\n  filter(ResidentCount &gt; 0)\n\n# Recalculate totals after cleaning\ntotal_population_after &lt;- sum(data$ResidentCount, na.rm = TRUE)\ntotal_rows_after &lt;- nrow(data)\n\ncat(\"Total population after cleaning:\", format(total_population_after, big.mark = \",\"), \"\\n\")\n\nTotal population after cleaning: 4,193,530 \n\ncat(\"Remaining rows:\", total_rows_after, \"\\n\")\n\nRemaining rows: 37243 \n\n\n\n\n\nNext, Using the duplicated function, we see that there are no duplicate entries in the data.\n\ndata[duplicated(data),]\n\n# A tibble: 0 × 6\n# ℹ 6 variables: PlanningArea &lt;chr&gt;, SubZone &lt;chr&gt;, Age &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   ResidentCount &lt;dbl&gt;, AgeGroup &lt;fct&gt;\n\n\n\n\n\nWe run the code below to check for any missing values, and there is none.\n\ncolSums(is.na(data))\n\n PlanningArea       SubZone           Age           Sex ResidentCount \n            0             0             0             0             0 \n     AgeGroup \n            0 \n\n\n\n\n\nWe run an overview of the final dataset again before proceeding to the visualization. Final dataset contains 37,243 rows and 7 columns:\n\nglimpse(data)\n\nRows: 37,243\nColumns: 6\n$ PlanningArea  &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", …\n$ SubZone       &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Centre\", \"Ang…\n$ Age           &lt;dbl&gt; 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9,…\n$ Sex           &lt;chr&gt; \"Males\", \"Females\", \"Males\", \"Females\", \"Males\", \"Female…\n$ ResidentCount &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 30, 10, 20, 10, 20, 30, …\n$ AgeGroup      &lt;fct&gt; 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 5–9, 5…\n\n\n\n\n\n\n\n\n\nInsights:\n\nThe population pyramid reveals a dominant working-age group between ages 30–44, forming the broadest segment of the chart, with largest age group for Female: from 35-39 age group: 166,150 and Males: from 30-34 age group with 155,630\nThe base is narrower, especially for those aged 0–14, which highlights the ongoing trend of declining birth rates.\nFemales significantly outnumber males from age 65 onwards, highlighting gender differences in life expectancy\nThe median age of 42 reinforces Singapore’s aging trend, with implications for healthcare and eldercare planning.\nThe median age of 42 underscores Singapore’s aging population, signaling increasing needs in healthcare, retirement, and eldercare.\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npyramid_data &lt;- data %&gt;%\n  group_by(AgeGroup, Sex) %&gt;%\n  summarise(ResidentCount = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    ResidentCountSigned = ifelse(Sex == \"Males\", -ResidentCount, ResidentCount),\n    fill_color = case_when(\n      Sex == \"Males\" ~ \"#4292c6\",\n      Sex == \"Females\" ~ \"#e377c2\",\n      TRUE ~ \"gray\"\n    ),\n    AgeGroup = factor(AgeGroup, levels = c(\"0–4\", \"5–9\", \"10–14\", \"15–19\", \"20–24\",\n                                           \"25–29\", \"30–34\", \"35–39\", \"40–44\", \"45–49\",\n                                           \"50–54\", \"55–59\", \"60–64\", \"65–69\", \"70–74\",\n                                           \"75–79\", \"80–84\", \"85–89\", \"90+\"))\n  )\n\nmedian_age &lt;- data %&gt;%\n  group_by(Age) %&gt;%\n  summarise(Total = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  arrange(Age) %&gt;%\n  mutate(cum_pop = cumsum(Total), prop = cum_pop / sum(Total)) %&gt;%\n  filter(prop &gt;= 0.5) %&gt;%\n  slice(1) %&gt;%\n  pull(Age)\n\nage_group_labels &lt;- levels(pyramid_data$AgeGroup)\nmedian_group_index &lt;- findInterval(median_age, seq(0, 100, by = 5))\nmedian_group &lt;- age_group_labels[median_group_index]\n\ntotal_males &lt;- pyramid_data %&gt;% filter(Sex == \"Males\") %&gt;% summarise(sum = sum(abs(ResidentCountSigned))) %&gt;% pull(sum)\ntotal_females &lt;- pyramid_data %&gt;% filter(Sex == \"Females\") %&gt;% summarise(sum = sum(ResidentCountSigned)) %&gt;% pull(sum)\n\nggplot(pyramid_data, aes(y = AgeGroup, x = ResidentCountSigned, fill = fill_color)) +\n  geom_col(width = 0.9) +\n  geom_text(aes(label = abs(ResidentCountSigned),\n                x = ifelse(ResidentCountSigned &lt; 0, ResidentCountSigned - 5000, ResidentCountSigned + 5000)),\n            hjust = ifelse(pyramid_data$ResidentCountSigned &lt; 0, 1, 0),\n            size = 3, color = \"black\") +\n  annotate(\"segment\",\n           x = -max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           xend = max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           y = median_group, yend = median_group,\n           linetype = \"dotted\", color = \"#A9A9A9\", linewidth = 0.9) +\n  annotate(\"text\",\n           x = max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           y = median_group,\n           label = paste0(\"Median: \", median_age),\n           hjust = 0, size = 2.8, color = \"black\", fontface = \"bold\") +\n  annotate(\"text\", y = \"0–4\",\n           x = -max(abs(pyramid_data$ResidentCountSigned)) * 0.95,\n           label = paste0(\"Males\\nTotal: \", format(total_males, big.mark = \",\")),\n           size = 2.6, color = \"#1E90FF\", fontface = \"bold\", hjust = 1) +\n  annotate(\"text\", y = \"0–4\",\n           x = max(abs(pyramid_data$ResidentCountSigned)) * 0.95,\n           label = paste0(\"Females\\nTotal: \", format(total_females, big.mark = \",\")),\n           size = 2.6, color = \"#c51b8a\", fontface = \"bold\", hjust = 0) +\n  scale_fill_identity() +\n  scale_x_continuous(labels = abs, expand = expansion(mult = c(0.12, 0.12))) +\n  labs(\n    title = \"Singapore’s Shifting Age Structure (June 2024)\",\n    subtitle = \"Middle-age Population Dominates; Youth Base Shrinking, Elderly Segment Rising\",\n    x = NULL,\n    y = \"Age Group (Years)\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 6)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 12)),\n    axis.text.y = element_text(size = 10),\n    axis.title.y = element_text(size = 11, face = \"bold\"),\n    axis.text.x = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank()\n  )\n\n\n\n\n\n\n\nInsights:\n\nThe top chart shows the proportion of elderly residents in the top 10 planning areas. Outram has the highest share, with 26.9% of its population are seniors, followed by Ang Mo Kio (24.3%) and Bukit Merah (23.4%). These established towns may benefit from enhanced elderly-supportive environments, such as barrier-free access, senior-oriented amenities, and close-proximity services.\nThe bottom chart presents the elderly resident count, with Bedok having the largest at 60,770, followed by Tampines (49,700) and Hougang (44,640). This is largely due to their larger area size and population base. These towns would benefit from service scaling, such as Active Ageing Centres (AACs), public transport connectivity, and healthcare access.\nWith Singapore’s elderly population projected to reach one in four residents (DOS, 2024), it is important to consider both distribution by proportion and resident count for effective planning.\nThis dual perspective supports the Ministry of Health’s 2023 Action Plan, which aims to double eldercare centres by 2025 and enhance community-based support (MOH, 2023).\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelderly_data &lt;- data %&gt;% filter(Age &gt;= 65)\n\ntotal_pop &lt;- data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Total_Pop = sum(ResidentCount, na.rm = TRUE))\n\nelderly_count &lt;- elderly_data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Elderly_Pop = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  arrange(desc(Elderly_Pop)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  mutate(PlanningArea = fct_reorder(PlanningArea, Elderly_Pop))\n\nelderly_prop &lt;- elderly_data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Elderly_Pop = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  left_join(total_pop, by = \"PlanningArea\") %&gt;%\n  mutate(Elderly_Proportion = Elderly_Pop / Total_Pop) %&gt;%\n  arrange(desc(Elderly_Proportion)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  mutate(PlanningArea = fct_reorder(PlanningArea, Elderly_Proportion))\n\n# Plot\np1 &lt;- ggplot(elderly_prop, aes(x = Elderly_Proportion, y = PlanningArea)) +\n  geom_col(fill = \"#4DAF4A\", width = 0.85) +\n  scale_x_continuous(\n    breaks = seq(0, 0.35, by = 0.05),\n    labels = percent_format(accuracy = 1),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Top 10 Planning Areas by Elderly Proportion (Age 65+)\",\n    x = \"Proportion of Elderly Residents\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title.x = element_text(size = 11),\n    panel.grid.major.x = element_line(color = \"grey90\"),\n    panel.grid.minor = element_blank()\n  )\n\n\np2 &lt;- ggplot(elderly_count, aes(x = Elderly_Pop, y = PlanningArea)) +\n  geom_col(fill = \"#4DAF4A\", width = 0.85) +\n  scale_x_continuous(\n    breaks = seq(0, 70000, by = 10000),\n    labels = comma_format(),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Top 10 Planning Areas by Elderly Resident Count (Age 65+)\",\n    x = \"Number of Elderly Residents\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title.x = element_text(size = 11),\n    panel.grid.major.x = element_line(color = \"grey90\"),\n    panel.grid.minor = element_blank()\n  )\n\np1 / p2\n\n\n\n\n\n\n\nInsights:\n\nTampines, Bedok, and Sengkang are top the list with over 250,000 residents each.\nMillennials (age 28–43) are the largest group in most PA, while Gen X dominates in Bedok, a mature estate.\nYounger generations (Gen Alpha and Gen Z) are more concentrated in newer towns like Sengkang, Punggol, and Jurong West, aligned with recent BTO developments that attract young families.\nThe distribution reflects a balanced generational mix, highlighting Singapore’s multigenerational living pattern—with both aging residents and young households sharing town spaces.\nThese trends align with Singapore’s Smart Nation and HDB’s ‘Designing for Life’ vision: fostering harmonious, inclusive communities where families of all ages can live, age, and thrive together through well-integrated facilities, technology, and people-first urban design.\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata &lt;- data %&gt;%\n  mutate(Age = as.numeric(Age),\n         Generation = case_when(\n           Age &lt;= 9 ~ \"Gen Alpha (≤9)\",\n           Age &lt;= 27 ~ \"Gen Z (10–27)\",\n           Age &lt;= 43 ~ \"Millennials (28–43)\",\n           Age &lt;= 59 ~ \"Gen X (44–59)\",\n           Age &lt;= 77 ~ \"Baby Boomers (60–77)\",\n           TRUE ~ \"Silent Gen (78+)\"\n         ))\n\ngen_by_area &lt;- data %&gt;%\n  group_by(PlanningArea, Generation) %&gt;%\n  summarise(ResidentCount = sum(ResidentCount, na.rm = TRUE), .groups = \"drop\")\n\ntop10_areas &lt;- gen_by_area %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(TotalPop = sum(ResidentCount)) %&gt;%\n  arrange(desc(TotalPop)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  pull(PlanningArea)\n\ngen_top10 &lt;- gen_by_area %&gt;%\n  filter(PlanningArea %in% top10_areas) %&gt;%\n  mutate(\n    PlanningArea = fct_reorder(PlanningArea, ResidentCount, .fun = sum, .desc = TRUE),\n    Generation = factor(Generation, levels = c(\"Silent Gen (78+)\", \"Baby Boomers (60–77)\",\n                                               \"Gen X (44–59)\", \"Millennials (28–43)\",\n                                               \"Gen Z (10–27)\", \"Gen Alpha (≤9)\"))\n  )\n\ngen_colors &lt;- c(\n  \"Silent Gen (78+)\" = \"#c6dbef\",\n  \"Baby Boomers (60–77)\" = \"#6baed6\",\n  \"Gen X (44–59)\" = \"#b2df8a\",\n  \"Millennials (28–43)\" = \"#33a02c\",\n  \"Gen Z (10–27)\" = \"#fb9a99\",\n  \"Gen Alpha (≤9)\" = \"#e31a1c\"\n)\n\n#Plot\nggplot(gen_top10, aes(x = PlanningArea, y = ResidentCount, fill = Generation)) +\n  geom_col(width = 0.8, color = \"white\") +\n  scale_fill_manual(values = gen_colors) +\n  scale_y_continuous(\n    labels = comma,\n    breaks = seq(0, 300000, 50000),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Generational Composition of Top 10 Most Populated Planning Areas\",\n    subtitle = \"Younger generations dominate newer towns, while older cohorts concentrate in mature estates\",\n    x = \"Planning Area\",\n    y = \"Resident Count\",\n    fill = \"Generation\"\n  ) +\n  theme_clean(base_size = 12) +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 11, hjust = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\nSingapore’s demographic structure, based on June 2024 data, highlights a maturing society with a dominant working-age group and a median age of 42. The growing share of seniors and the narrowing base of younger age groups reflect the effects of population aging and low birth rates. Mature estates such as Outram have the highest proportion of elderly residents, while Bedok and Tampines house the largest absolute numbers. In contrast, newer towns like Sengkang and Punggol show higher concentrations of younger generations—particularly Gen Alpha and Gen Z—driven by recent BTO developments attracting young families. Millennials remain the largest generational group across most areas, reinforcing their role in shaping urban life. This evolving yet balanced generational landscape underscores the need for inclusive community planning that supports both young families and seniors—fostering intergenerational harmony and enabling families to live, age, and thrive together.\n\n\n\n\nDepartment of Statistics Singapore. (2024). Population Trends 2024.\nRetrieved from: https://www.singstat.gov.sg/publications/population/population-trends\nMinistry of Health Singapore. (2023). Action Plan for Successful Ageing.\nRetrieved from: https://www.moh.gov.sg/newsroom/launch-of-the-2023-action-plan-for-successful-ageing\nHousing & Development Board (HDB). (2021). Designing for Life: Community Planning and Design Guide.\nRetrieved from: https://www.hdb.gov.sg/cs/infoweb/designing-for-life\nSmart Nation and Digital Government Office. (2023). Smart Nation: Empowering Everyone Through Technology.\nRetrieved from: https://www.smartnation.gov.sg\nSingapore Department of Statistics. (n.d.). National Statistical Standards.\nRetrieved from: https://www.singstat.gov.sg/standards"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#overview",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#overview",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Creating enlightening and truthful data visualizations involves focusing on accuracy, transparency, and the ability to effectively communicate insights. It’s about presenting data in a way that is both informative and aesthetically pleasing, ensuring the audience can grasp the information quickly and accurately."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#setting-the-scene",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#setting-the-scene",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "A local online media company that publishes daily content on digital platforms is planning to release an article on demographic structures and distribution of Singapore in 2024."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#the-task",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#the-task",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Assuming the role of the graphical editor of the media company, we are tasked to prepare at most three data visualization for the article."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#getting-started",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#getting-started",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "We load the following R packages using the pacman::p_load() function:\n\ntidyverse: R packages designed for data science\nggrepel: to provides geoms for ggplot2 to repel overlapping text labels\nggthemes: to use additional themes for ggplot2\npatchwork: to prepare composite figure created using ggplot2\nscales: to provide the internal scaling infrastructure used by ggplot2\nggpubr to create publication ready ggplot2 plots.\n\nThe code chunk below uses the p_load() function in the pacman package to check if the packages are installed in the computer.\n\npacman::p_load(tidyverse, ggrepel, patchwork, ggthemes, scales,\n               ggpubr) \n\n\n\n\nTo accomplish the task, Singapore Residents by Planning Area / Subzone, Single Year of Age and Sex, June 2024 dataset shared by Department of Statistics, Singapore (DOS) will be used and we wil load it as follows:\n\ndata &lt;- read_csv(\"data/respopagesex2024.csv\", col_names = TRUE)\n\n\n\n\n\n\nWe first take a look at the data. Using the code below, we can get the details of the dataset which contains 60,424 rows and 6 columns.\n\nglimpse(data)\n\nRows: 60,424\nColumns: 6\n$ PA   &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo K…\n$ SZ   &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Centre\", \"Ang Mo Kio T…\n$ Age  &lt;chr&gt; \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", \"4\", \"4\", \"5\", \"5\", \"6\", …\n$ Sex  &lt;chr&gt; \"Males\", \"Females\", \"Males\", \"Females\", \"Males\", \"Females\", \"Male…\n$ Pop  &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 30, 10, 20, 10, 20, 30, 30, 10, 3…\n$ Time &lt;dbl&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024,…\n\n\n\n\n\n\nWe notice that there is only one value in Time column (2024) which will not be used for further analysis, we will delete this column as per the code chunk below:\n\n\ndata &lt;- data %&gt;% select(-Time)\n\n\nWe will rename the column names in the dataset for clarity, as detailed provided by the Department of Statistics (DOS), as follows:\n\nPA → Planning Area\nSZ → Subzone\nPop → Resident Count\n\n\n\n\n\n\nSide Note:\n\n\n\nPlease note: according to the DOS accompanying documentation of this dataset, the population figures in the csv file have been rounded to the nearest 10, and as such, total counts may not sum exactly due to rounding adjustments.\n\n\n\ncolnames(data) &lt;- c(\"PlanningArea\", \"SubZone\", \"Age\", \"Sex\", \"ResidentCount\")\n\n\nNext, we observe that for the Age column, there is a value of : “90_and_over”. We will replace this value with “90” and change the data type from string/character to numeric and then create a new column to classify the age according to the age bracket in the interval of 5 years as per the standard age group published in DOS:\n\n\ndata &lt;- data %&gt;%\n  mutate(\n    # Normalize Age values to lowercase\n    Age = str_to_lower(Age),\n    \n    # Replace \"90_and_over\" with \"90\"\n    Age = ifelse(Age == \"90_and_over\", \"90\", Age),\n    \n    # Convert to numeric\n    Age = as.numeric(Age),\n    \n    # Create AgeGroup with standard bins\n    AgeGroup = cut(Age,\n                   breaks = c(0,4,9,14,19,24,29,34,39,44,49,54,59,64,69,74,79,84,89, Inf),\n                   labels = c(\"0–4\", \"5–9\", \"10–14\", \"15–19\", \"20–24\", \"25–29\",\n                              \"30–34\", \"35–39\", \"40–44\", \"45–49\", \"50–54\", \n                              \"55–59\", \"60–64\", \"65–69\", \"70–74\", \"75–79\", \n                              \"80–84\", \"85–89\", \"90+\"),\n                   right = TRUE, include.lowest = TRUE)\n  )\n\n\nFurther observation of the dataset, we discover there are multiple rows with “0” values in the “Pop”/“ResidentCount” column. We will remove these rows as per the code chunk below, and calculate the number of rows and total population before and after the deletion to ensure completeness:\n\n\n# Total population before removing zero-pop rows\ntotal_population_before &lt;- sum(data$ResidentCount, na.rm = TRUE)\ntotal_rows_before &lt;- nrow(data)\n\n# Count and show how many rows have 0 population\nzero_count &lt;- data %&gt;%\n  filter(ResidentCount == 0) %&gt;%\n  nrow()\n\ncat(\"Total population before cleaning:\", format(total_population_before, big.mark = \",\"), \"\\n\")\n\nTotal population before cleaning: 4,193,530 \n\ncat(\"Total rows before cleaning:\", total_rows_before, \"\\n\")\n\nTotal rows before cleaning: 60424 \n\ncat(\"Rows with 0 ResidentCount removed:\", zero_count, \"\\n\")\n\nRows with 0 ResidentCount removed: 23181 \n\n# Remove rows with 0 population\ndata &lt;- data %&gt;%\n  filter(ResidentCount &gt; 0)\n\n# Recalculate totals after cleaning\ntotal_population_after &lt;- sum(data$ResidentCount, na.rm = TRUE)\ntotal_rows_after &lt;- nrow(data)\n\ncat(\"Total population after cleaning:\", format(total_population_after, big.mark = \",\"), \"\\n\")\n\nTotal population after cleaning: 4,193,530 \n\ncat(\"Remaining rows:\", total_rows_after, \"\\n\")\n\nRemaining rows: 37243 \n\n\n\n\n\nNext, Using the duplicated function, we see that there are no duplicate entries in the data.\n\ndata[duplicated(data),]\n\n# A tibble: 0 × 6\n# ℹ 6 variables: PlanningArea &lt;chr&gt;, SubZone &lt;chr&gt;, Age &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   ResidentCount &lt;dbl&gt;, AgeGroup &lt;fct&gt;\n\n\n\n\n\nWe run the code below to check for any missing values, and there is none.\n\ncolSums(is.na(data))\n\n PlanningArea       SubZone           Age           Sex ResidentCount \n            0             0             0             0             0 \n     AgeGroup \n            0 \n\n\n\n\n\nWe run an overview of the final dataset again before proceeding to the visualization. Final dataset contains 37,243 rows and 7 columns:\n\nglimpse(data)\n\nRows: 37,243\nColumns: 6\n$ PlanningArea  &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", …\n$ SubZone       &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Centre\", \"Ang…\n$ Age           &lt;dbl&gt; 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9,…\n$ Sex           &lt;chr&gt; \"Males\", \"Females\", \"Males\", \"Females\", \"Males\", \"Female…\n$ ResidentCount &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 30, 10, 20, 10, 20, 30, …\n$ AgeGroup      &lt;fct&gt; 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 0–4, 5–9, 5…"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#data-visualization",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#data-visualization",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Insights:\n\nThe population pyramid reveals a dominant working-age group between ages 30–44, forming the broadest segment of the chart, with largest age group for Female: from 35-39 age group: 166,150 and Males: from 30-34 age group with 155,630\nThe base is narrower, especially for those aged 0–14, which highlights the ongoing trend of declining birth rates.\nFemales significantly outnumber males from age 65 onwards, highlighting gender differences in life expectancy\nThe median age of 42 reinforces Singapore’s aging trend, with implications for healthcare and eldercare planning.\nThe median age of 42 underscores Singapore’s aging population, signaling increasing needs in healthcare, retirement, and eldercare.\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npyramid_data &lt;- data %&gt;%\n  group_by(AgeGroup, Sex) %&gt;%\n  summarise(ResidentCount = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    ResidentCountSigned = ifelse(Sex == \"Males\", -ResidentCount, ResidentCount),\n    fill_color = case_when(\n      Sex == \"Males\" ~ \"#4292c6\",\n      Sex == \"Females\" ~ \"#e377c2\",\n      TRUE ~ \"gray\"\n    ),\n    AgeGroup = factor(AgeGroup, levels = c(\"0–4\", \"5–9\", \"10–14\", \"15–19\", \"20–24\",\n                                           \"25–29\", \"30–34\", \"35–39\", \"40–44\", \"45–49\",\n                                           \"50–54\", \"55–59\", \"60–64\", \"65–69\", \"70–74\",\n                                           \"75–79\", \"80–84\", \"85–89\", \"90+\"))\n  )\n\nmedian_age &lt;- data %&gt;%\n  group_by(Age) %&gt;%\n  summarise(Total = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  arrange(Age) %&gt;%\n  mutate(cum_pop = cumsum(Total), prop = cum_pop / sum(Total)) %&gt;%\n  filter(prop &gt;= 0.5) %&gt;%\n  slice(1) %&gt;%\n  pull(Age)\n\nage_group_labels &lt;- levels(pyramid_data$AgeGroup)\nmedian_group_index &lt;- findInterval(median_age, seq(0, 100, by = 5))\nmedian_group &lt;- age_group_labels[median_group_index]\n\ntotal_males &lt;- pyramid_data %&gt;% filter(Sex == \"Males\") %&gt;% summarise(sum = sum(abs(ResidentCountSigned))) %&gt;% pull(sum)\ntotal_females &lt;- pyramid_data %&gt;% filter(Sex == \"Females\") %&gt;% summarise(sum = sum(ResidentCountSigned)) %&gt;% pull(sum)\n\nggplot(pyramid_data, aes(y = AgeGroup, x = ResidentCountSigned, fill = fill_color)) +\n  geom_col(width = 0.9) +\n  geom_text(aes(label = abs(ResidentCountSigned),\n                x = ifelse(ResidentCountSigned &lt; 0, ResidentCountSigned - 5000, ResidentCountSigned + 5000)),\n            hjust = ifelse(pyramid_data$ResidentCountSigned &lt; 0, 1, 0),\n            size = 3, color = \"black\") +\n  annotate(\"segment\",\n           x = -max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           xend = max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           y = median_group, yend = median_group,\n           linetype = \"dotted\", color = \"#A9A9A9\", linewidth = 0.9) +\n  annotate(\"text\",\n           x = max(abs(pyramid_data$ResidentCountSigned)) * 1.5,\n           y = median_group,\n           label = paste0(\"Median: \", median_age),\n           hjust = 0, size = 2.8, color = \"black\", fontface = \"bold\") +\n  annotate(\"text\", y = \"0–4\",\n           x = -max(abs(pyramid_data$ResidentCountSigned)) * 0.95,\n           label = paste0(\"Males\\nTotal: \", format(total_males, big.mark = \",\")),\n           size = 2.6, color = \"#1E90FF\", fontface = \"bold\", hjust = 1) +\n  annotate(\"text\", y = \"0–4\",\n           x = max(abs(pyramid_data$ResidentCountSigned)) * 0.95,\n           label = paste0(\"Females\\nTotal: \", format(total_females, big.mark = \",\")),\n           size = 2.6, color = \"#c51b8a\", fontface = \"bold\", hjust = 0) +\n  scale_fill_identity() +\n  scale_x_continuous(labels = abs, expand = expansion(mult = c(0.12, 0.12))) +\n  labs(\n    title = \"Singapore’s Shifting Age Structure (June 2024)\",\n    subtitle = \"Middle-age Population Dominates; Youth Base Shrinking, Elderly Segment Rising\",\n    x = NULL,\n    y = \"Age Group (Years)\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 6)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 12)),\n    axis.text.y = element_text(size = 10),\n    axis.title.y = element_text(size = 11, face = \"bold\"),\n    axis.text.x = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank()\n  )\n\n\n\n\n\n\n\nInsights:\n\nThe top chart shows the proportion of elderly residents in the top 10 planning areas. Outram has the highest share, with 26.9% of its population are seniors, followed by Ang Mo Kio (24.3%) and Bukit Merah (23.4%). These established towns may benefit from enhanced elderly-supportive environments, such as barrier-free access, senior-oriented amenities, and close-proximity services.\nThe bottom chart presents the elderly resident count, with Bedok having the largest at 60,770, followed by Tampines (49,700) and Hougang (44,640). This is largely due to their larger area size and population base. These towns would benefit from service scaling, such as Active Ageing Centres (AACs), public transport connectivity, and healthcare access.\nWith Singapore’s elderly population projected to reach one in four residents (DOS, 2024), it is important to consider both distribution by proportion and resident count for effective planning.\nThis dual perspective supports the Ministry of Health’s 2023 Action Plan, which aims to double eldercare centres by 2025 and enhance community-based support (MOH, 2023).\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelderly_data &lt;- data %&gt;% filter(Age &gt;= 65)\n\ntotal_pop &lt;- data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Total_Pop = sum(ResidentCount, na.rm = TRUE))\n\nelderly_count &lt;- elderly_data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Elderly_Pop = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  arrange(desc(Elderly_Pop)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  mutate(PlanningArea = fct_reorder(PlanningArea, Elderly_Pop))\n\nelderly_prop &lt;- elderly_data %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(Elderly_Pop = sum(ResidentCount, na.rm = TRUE)) %&gt;%\n  left_join(total_pop, by = \"PlanningArea\") %&gt;%\n  mutate(Elderly_Proportion = Elderly_Pop / Total_Pop) %&gt;%\n  arrange(desc(Elderly_Proportion)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  mutate(PlanningArea = fct_reorder(PlanningArea, Elderly_Proportion))\n\n# Plot\np1 &lt;- ggplot(elderly_prop, aes(x = Elderly_Proportion, y = PlanningArea)) +\n  geom_col(fill = \"#4DAF4A\", width = 0.85) +\n  scale_x_continuous(\n    breaks = seq(0, 0.35, by = 0.05),\n    labels = percent_format(accuracy = 1),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Top 10 Planning Areas by Elderly Proportion (Age 65+)\",\n    x = \"Proportion of Elderly Residents\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title.x = element_text(size = 11),\n    panel.grid.major.x = element_line(color = \"grey90\"),\n    panel.grid.minor = element_blank()\n  )\n\n\np2 &lt;- ggplot(elderly_count, aes(x = Elderly_Pop, y = PlanningArea)) +\n  geom_col(fill = \"#4DAF4A\", width = 0.85) +\n  scale_x_continuous(\n    breaks = seq(0, 70000, by = 10000),\n    labels = comma_format(),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Top 10 Planning Areas by Elderly Resident Count (Age 65+)\",\n    x = \"Number of Elderly Residents\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.background = element_rect(fill = \"#FFFCE8\", color = NA),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title.x = element_text(size = 11),\n    panel.grid.major.x = element_line(color = \"grey90\"),\n    panel.grid.minor = element_blank()\n  )\n\np1 / p2\n\n\n\n\n\n\n\nInsights:\n\nTampines, Bedok, and Sengkang are top the list with over 250,000 residents each.\nMillennials (age 28–43) are the largest group in most PA, while Gen X dominates in Bedok, a mature estate.\nYounger generations (Gen Alpha and Gen Z) are more concentrated in newer towns like Sengkang, Punggol, and Jurong West, aligned with recent BTO developments that attract young families.\nThe distribution reflects a balanced generational mix, highlighting Singapore’s multigenerational living pattern—with both aging residents and young households sharing town spaces.\nThese trends align with Singapore’s Smart Nation and HDB’s ‘Designing for Life’ vision: fostering harmonious, inclusive communities where families of all ages can live, age, and thrive together through well-integrated facilities, technology, and people-first urban design.\n\n\nThe PlotThe Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata &lt;- data %&gt;%\n  mutate(Age = as.numeric(Age),\n         Generation = case_when(\n           Age &lt;= 9 ~ \"Gen Alpha (≤9)\",\n           Age &lt;= 27 ~ \"Gen Z (10–27)\",\n           Age &lt;= 43 ~ \"Millennials (28–43)\",\n           Age &lt;= 59 ~ \"Gen X (44–59)\",\n           Age &lt;= 77 ~ \"Baby Boomers (60–77)\",\n           TRUE ~ \"Silent Gen (78+)\"\n         ))\n\ngen_by_area &lt;- data %&gt;%\n  group_by(PlanningArea, Generation) %&gt;%\n  summarise(ResidentCount = sum(ResidentCount, na.rm = TRUE), .groups = \"drop\")\n\ntop10_areas &lt;- gen_by_area %&gt;%\n  group_by(PlanningArea) %&gt;%\n  summarise(TotalPop = sum(ResidentCount)) %&gt;%\n  arrange(desc(TotalPop)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  pull(PlanningArea)\n\ngen_top10 &lt;- gen_by_area %&gt;%\n  filter(PlanningArea %in% top10_areas) %&gt;%\n  mutate(\n    PlanningArea = fct_reorder(PlanningArea, ResidentCount, .fun = sum, .desc = TRUE),\n    Generation = factor(Generation, levels = c(\"Silent Gen (78+)\", \"Baby Boomers (60–77)\",\n                                               \"Gen X (44–59)\", \"Millennials (28–43)\",\n                                               \"Gen Z (10–27)\", \"Gen Alpha (≤9)\"))\n  )\n\ngen_colors &lt;- c(\n  \"Silent Gen (78+)\" = \"#c6dbef\",\n  \"Baby Boomers (60–77)\" = \"#6baed6\",\n  \"Gen X (44–59)\" = \"#b2df8a\",\n  \"Millennials (28–43)\" = \"#33a02c\",\n  \"Gen Z (10–27)\" = \"#fb9a99\",\n  \"Gen Alpha (≤9)\" = \"#e31a1c\"\n)\n\n#Plot\nggplot(gen_top10, aes(x = PlanningArea, y = ResidentCount, fill = Generation)) +\n  geom_col(width = 0.8, color = \"white\") +\n  scale_fill_manual(values = gen_colors) +\n  scale_y_continuous(\n    labels = comma,\n    breaks = seq(0, 300000, 50000),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(\n    title = \"Generational Composition of Top 10 Most Populated Planning Areas\",\n    subtitle = \"Younger generations dominate newer towns, while older cohorts concentrate in mature estates\",\n    x = \"Planning Area\",\n    y = \"Resident Count\",\n    fill = \"Generation\"\n  ) +\n  theme_clean(base_size = 12) +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 11, hjust = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    legend.position = \"right\"\n  )"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#summary",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#summary",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Singapore’s demographic structure, based on June 2024 data, highlights a maturing society with a dominant working-age group and a median age of 42. The growing share of seniors and the narrowing base of younger age groups reflect the effects of population aging and low birth rates. Mature estates such as Outram have the highest proportion of elderly residents, while Bedok and Tampines house the largest absolute numbers. In contrast, newer towns like Sengkang and Punggol show higher concentrations of younger generations—particularly Gen Alpha and Gen Z—driven by recent BTO developments attracting young families. Millennials remain the largest generational group across most areas, reinforcing their role in shaping urban life. This evolving yet balanced generational landscape underscores the need for inclusive community planning that supports both young families and seniors—fostering intergenerational harmony and enabling families to live, age, and thrive together."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#references",
    "href": "Take-home_Ex/Take-home_Ex_1/Take-Home_Ex1.html#references",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Department of Statistics Singapore. (2024). Population Trends 2024.\nRetrieved from: https://www.singstat.gov.sg/publications/population/population-trends\nMinistry of Health Singapore. (2023). Action Plan for Successful Ageing.\nRetrieved from: https://www.moh.gov.sg/newsroom/launch-of-the-2023-action-plan-for-successful-ageing\nHousing & Development Board (HDB). (2021). Designing for Life: Community Planning and Design Guide.\nRetrieved from: https://www.hdb.gov.sg/cs/infoweb/designing-for-life\nSmart Nation and Digital Government Office. (2023). Smart Nation: Empowering Everyone Through Technology.\nRetrieved from: https://www.smartnation.gov.sg\nSingapore Department of Statistics. (n.d.). National Statistical Standards.\nRetrieved from: https://www.singstat.gov.sg/standards"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html",
    "title": "Hands-on Exercise 06",
    "section": "",
    "text": "By the end of this hands-on exercise we will be able create the followings data visualisation by using R packages:\n\nplotting a calender heatmap by using ggplot2 functions,\nplotting a cycle plot by using ggplot2 function,\nplotting a slopegraph\nplotting a horizon chart\n\n\n\n\n\n\n\nWrite a code chunk to check, install and launch the following R packages: scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table and tidyverse.\n\n\nShow the code\n\n\npacman::p_load(scales, viridis, lubridate, ggthemes,\n               gridExtra, readxl, knitr, data.table,\n               CGPfunctions, ggHoriPlot, tidyverse)\n\n\n\n\n\nIn this section, we will learn how to plot a calender heatmap programmatically by using ggplot2 package.\n\nBy the end of this section, we will be able to:\n\nplot a calender heatmap by using ggplot2 functions and extension,\nto write function using R programming,\nto derive specific date and time related field by using base R and lubridate packages\nto perform data preparation task by using tidyr and dplyr packages.\n\n\n\nFor the purpose of this hands-on exercise, eventlog.csv file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.\n\n\n\nFirst, we will use the code chunk below to import eventlog.csv file into R environment and called the data frame as attacks.\n\nattacks &lt;- read_csv(\"data/eventlog.csv\")\n\n\n\n\nIt is always a good practice to examine the imported data frame before further analysis is performed.\nFor example, kable() can be used to review the structure of the imported data frame.\n\nkable(head(attacks))\n\n\n\n\ntimestamp\nsource_country\ntz\n\n\n\n\n2015-03-12 15:59:16\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:00:48\nFR\nEurope/Paris\n\n\n2015-03-12 16:02:26\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:02:38\nUS\nAmerica/Chicago\n\n\n2015-03-12 16:03:22\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:03:45\nCN\nAsia/Shanghai\n\n\n\n\n\nThere are three columns, namely timestamp, source_country and tz.\ntimestamp field stores date-time values in POSIXct format. source_country field stores the source of the attack. It is in ISO 3166-1 alpha-2 country code. tz field stores time zone of the source IP address.\n\n\n\nStep 1: Deriving weekday and hour of day fields\nBefore we can plot the calender heatmap, two new fields namely wkday and hour need to be derived. In this step, we will write a function to perform the task.\n\nmake_hr_wkday &lt;- function(ts, sc, tz) {\n  real_times &lt;- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt &lt;- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n}\n\n\n\n\n\n\n\nNote\n\n\n\n\nymd_hms() and hour() are from lubridate package, and\nweekdays() is a base R function.\n\n\n\nStep 2: Deriving the attacks tibble data frame\n\nwkday_levels &lt;- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks &lt;- attacks %&gt;%\n  group_by(tz) %&gt;%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %&gt;% \n  ungroup() %&gt;% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n\n\n\n\n\n\n\nNote\n\n\n\nBeside extracting the necessary data into attacks data frame, mutate() of dplyr package is used to convert wkday and hour fields into factor so they’ll be ordered when plotting\n\n\nTable below shows the tidy tibble table after processing.\n\nkable(head(attacks))\n\n\n\n\ntz\nsource_country\nwkday\nhour\n\n\n\n\nAfrica/Cairo\nBG\nSaturday\n20\n\n\nAfrica/Cairo\nTW\nSunday\n6\n\n\nAfrica/Cairo\nTW\nSunday\n8\n\n\nAfrica/Cairo\nCN\nSunday\n11\n\n\nAfrica/Cairo\nUS\nSunday\n15\n\n\nAfrica/Cairo\nCA\nMonday\n11\n\n\n\n\n\n\n\n\n\ngrouped &lt;- attacks %&gt;% \n  count(wkday, hour) %&gt;% \n  ungroup() %&gt;%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunk\n\n\n\n\na tibble data table called grouped is derived by aggregating the attack by wkday and hour fields.\na new field called n is derived by using group_by() and count() functions.\nna.omit() is used to exclude missing value.\ngeom_tile() is used to plot tiles (grids) at each x and y position. color and size arguments are used to specify the border color and line size of the tiles.\ntheme_tufte() of ggthemes package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.\ncoord_equal() is used to ensure the plot will have an aspect ratio of 1:1.\nscale_fill_gradient() function is used to creates a two colour gradient (low-high).\n\n\n\nThen we can simply group the count by hour and wkday and plot it, since we know that we have values for every combination there’s no need to further preprocess the data.\n\n\n\nChallenge: Building multiple heatmaps for the top four countries with the highest number of attacks.\n\n\n\n\nStep 1: Deriving attack by country object\nIn order to identify the top 4 countries with the highest number of attacks, you are required to do the followings:\n\ncount the number of attacks by country,\ncalculate the percent of attackes by country, and\nsave the results in a tibble data frame.\n\n\nattacks_by_country &lt;- count(\n  attacks, source_country) %&gt;%\n  mutate(percent = percent(n/sum(n))) %&gt;%\n  arrange(desc(n))\n\nStep 2: Preparing the tidy data frame\nIn this step, you are required to extract the attack records of the top 4 countries from attacks data frame and save the data in a new tibble data frame (i.e. top4_attacks).\n\ntop4 &lt;- attacks_by_country$source_country[1:4]\ntop4_attacks &lt;- attacks %&gt;%\n  filter(source_country %in% top4) %&gt;%\n  count(source_country, wkday, hour) %&gt;%\n  ungroup() %&gt;%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %&gt;%\n  na.omit()\n\n\n\n\nStep 3: Plotting the Multiple Calender Heatmap by using ggplot2 package.\n\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n\n\n\n\n\n\n\n\n\n\n\n\nIn this section, you will learn how to plot a cycle plot showing the time-series patterns and trend of visitor arrivals from Vietnam programmatically by using ggplot2 functions.\n\n\n\nFor the purpose of this hands-on exercise, arrivals_by_air.xlsx will be used.\nThe code chunk below imports arrivals_by_air.xlsx by using read_excel() of readxl package and save it as a tibble data frame called air.\n\nair &lt;- read_excel(\"data/arrivals_by_air.xlsx\")\n\n\n\n\nNext, two new fields called month and year are derived from Month-Year field.\n\nair$month &lt;- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year &lt;- year(ymd(air$`Month-Year`))\n\n\n\n\nNext, the code chunk below is use to extract data for the target country (i.e. Vietnam)\n\nVietnam &lt;- air %&gt;% \n  select(`Vietnam`, \n         month, \n         year) %&gt;%\n  filter(year &gt;= 2010)\n\n\n\n\nThe code chunk below uses group_by() and summarise() of dplyr to compute year average arrivals by month.\n\nhline.data &lt;- Vietnam %&gt;% \n  group_by(month) %&gt;%\n  summarise(avgvalue = mean(`Vietnam`))\n\n\n\n\nThe code chunk below is used to plot the cycle plot as shown in Slide 12/23.\n\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_tufte(base_family = \"Helvetica\")\n\n\n\n\n\n\n\n\n\n\n\n\nIn this section we will learn how to plot a slopegraph by using R.\nBefore getting start, make sure that CGPfunctions has been installed and loaded onto R environment. Then, refer to Using newggslopegraph to learn more about the function. Lastly, read more about newggslopegraph() and its arguments by referring to this link.\n\n\nImport the rice data set into R environment by using the code chunk below.\n\nrice &lt;- read_csv(\"data/rice.csv\")\n\n\n\n\nNext, code chunk below will be used to plot a basic slopegraph as shown below.\n\nrice %&gt;% \n  mutate(Year = factor(Year)) %&gt;%\n  filter(Year %in% c(1961, 1980)) %&gt;%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Dr. Kam Tin Seong\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunk\n\n\n\nFor effective data visualisation design, factor() is used convert the value type of Year field from numeric to factor.\n\n\n\n\n\n\n\n\n\nA taxonomy of temporal data visualization techniques\nEdward Tufte’s “Slopegraphs”\nIntroduction to Cycle Plots\nVisualizing Change: An Innovation in Time-Series Analysis\nThe Development of the Horizon Graph\n\n\n\n\n\nwhat is a slopegraph?\nSlopegraph Update\nTime on the Horizon\nTimeSearcher\nWhat is a slopegraph?\nDonahue, Rafe M.J. Fundamental Statistical Concepts in Presenting Data: Principles for Constructing Better Graphics. This article provide a real world example of building truthful and functional time series graph.\nHockey stick graph at wiki.\nMichael E. Mann, Raymond S. Bradley, Malcolm K. Hughes (1999) “Northern hemisphere temperatures during the past millennium: Inferences, uncertainties, and limitations”. Geophysical Research Letters, Vol. 26, No. pp. 759-762.\nThe Guardian (2010) “Hockey stick graph took pride of place in IPCC report, despite doubts”."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#learning-outcome",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#learning-outcome",
    "title": "Hands-on Exercise 06",
    "section": "",
    "text": "By the end of this hands-on exercise we will be able create the followings data visualisation by using R packages:\n\nplotting a calender heatmap by using ggplot2 functions,\nplotting a cycle plot by using ggplot2 function,\nplotting a slopegraph\nplotting a horizon chart"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#do-it-yourself",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#do-it-yourself",
    "title": "Hands-on Exercise 06",
    "section": "",
    "text": "Write a code chunk to check, install and launch the following R packages: scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table and tidyverse.\n\n\nShow the code\n\n\npacman::p_load(scales, viridis, lubridate, ggthemes,\n               gridExtra, readxl, knitr, data.table,\n               CGPfunctions, ggHoriPlot, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-calendar-heatmap",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-calendar-heatmap",
    "title": "Hands-on Exercise 06",
    "section": "",
    "text": "In this section, we will learn how to plot a calender heatmap programmatically by using ggplot2 package.\n\nBy the end of this section, we will be able to:\n\nplot a calender heatmap by using ggplot2 functions and extension,\nto write function using R programming,\nto derive specific date and time related field by using base R and lubridate packages\nto perform data preparation task by using tidyr and dplyr packages.\n\n\n\nFor the purpose of this hands-on exercise, eventlog.csv file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.\n\n\n\nFirst, we will use the code chunk below to import eventlog.csv file into R environment and called the data frame as attacks.\n\nattacks &lt;- read_csv(\"data/eventlog.csv\")\n\n\n\n\nIt is always a good practice to examine the imported data frame before further analysis is performed.\nFor example, kable() can be used to review the structure of the imported data frame.\n\nkable(head(attacks))\n\n\n\n\ntimestamp\nsource_country\ntz\n\n\n\n\n2015-03-12 15:59:16\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:00:48\nFR\nEurope/Paris\n\n\n2015-03-12 16:02:26\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:02:38\nUS\nAmerica/Chicago\n\n\n2015-03-12 16:03:22\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:03:45\nCN\nAsia/Shanghai\n\n\n\n\n\nThere are three columns, namely timestamp, source_country and tz.\ntimestamp field stores date-time values in POSIXct format. source_country field stores the source of the attack. It is in ISO 3166-1 alpha-2 country code. tz field stores time zone of the source IP address.\n\n\n\nStep 1: Deriving weekday and hour of day fields\nBefore we can plot the calender heatmap, two new fields namely wkday and hour need to be derived. In this step, we will write a function to perform the task.\n\nmake_hr_wkday &lt;- function(ts, sc, tz) {\n  real_times &lt;- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt &lt;- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n}\n\n\n\n\n\n\n\nNote\n\n\n\n\nymd_hms() and hour() are from lubridate package, and\nweekdays() is a base R function.\n\n\n\nStep 2: Deriving the attacks tibble data frame\n\nwkday_levels &lt;- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks &lt;- attacks %&gt;%\n  group_by(tz) %&gt;%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %&gt;% \n  ungroup() %&gt;% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n\n\n\n\n\n\n\nNote\n\n\n\nBeside extracting the necessary data into attacks data frame, mutate() of dplyr package is used to convert wkday and hour fields into factor so they’ll be ordered when plotting\n\n\nTable below shows the tidy tibble table after processing.\n\nkable(head(attacks))\n\n\n\n\ntz\nsource_country\nwkday\nhour\n\n\n\n\nAfrica/Cairo\nBG\nSaturday\n20\n\n\nAfrica/Cairo\nTW\nSunday\n6\n\n\nAfrica/Cairo\nTW\nSunday\n8\n\n\nAfrica/Cairo\nCN\nSunday\n11\n\n\nAfrica/Cairo\nUS\nSunday\n15\n\n\nAfrica/Cairo\nCA\nMonday\n11\n\n\n\n\n\n\n\n\n\ngrouped &lt;- attacks %&gt;% \n  count(wkday, hour) %&gt;% \n  ungroup() %&gt;%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunk\n\n\n\n\na tibble data table called grouped is derived by aggregating the attack by wkday and hour fields.\na new field called n is derived by using group_by() and count() functions.\nna.omit() is used to exclude missing value.\ngeom_tile() is used to plot tiles (grids) at each x and y position. color and size arguments are used to specify the border color and line size of the tiles.\ntheme_tufte() of ggthemes package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.\ncoord_equal() is used to ensure the plot will have an aspect ratio of 1:1.\nscale_fill_gradient() function is used to creates a two colour gradient (low-high).\n\n\n\nThen we can simply group the count by hour and wkday and plot it, since we know that we have values for every combination there’s no need to further preprocess the data.\n\n\n\nChallenge: Building multiple heatmaps for the top four countries with the highest number of attacks.\n\n\n\n\nStep 1: Deriving attack by country object\nIn order to identify the top 4 countries with the highest number of attacks, you are required to do the followings:\n\ncount the number of attacks by country,\ncalculate the percent of attackes by country, and\nsave the results in a tibble data frame.\n\n\nattacks_by_country &lt;- count(\n  attacks, source_country) %&gt;%\n  mutate(percent = percent(n/sum(n))) %&gt;%\n  arrange(desc(n))\n\nStep 2: Preparing the tidy data frame\nIn this step, you are required to extract the attack records of the top 4 countries from attacks data frame and save the data in a new tibble data frame (i.e. top4_attacks).\n\ntop4 &lt;- attacks_by_country$source_country[1:4]\ntop4_attacks &lt;- attacks %&gt;%\n  filter(source_country %in% top4) %&gt;%\n  count(source_country, wkday, hour) %&gt;%\n  ungroup() %&gt;%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %&gt;%\n  na.omit()\n\n\n\n\nStep 3: Plotting the Multiple Calender Heatmap by using ggplot2 package.\n\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-cycle-plot",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-cycle-plot",
    "title": "Hands-on Exercise 06",
    "section": "",
    "text": "In this section, you will learn how to plot a cycle plot showing the time-series patterns and trend of visitor arrivals from Vietnam programmatically by using ggplot2 functions.\n\n\n\nFor the purpose of this hands-on exercise, arrivals_by_air.xlsx will be used.\nThe code chunk below imports arrivals_by_air.xlsx by using read_excel() of readxl package and save it as a tibble data frame called air.\n\nair &lt;- read_excel(\"data/arrivals_by_air.xlsx\")\n\n\n\n\nNext, two new fields called month and year are derived from Month-Year field.\n\nair$month &lt;- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year &lt;- year(ymd(air$`Month-Year`))\n\n\n\n\nNext, the code chunk below is use to extract data for the target country (i.e. Vietnam)\n\nVietnam &lt;- air %&gt;% \n  select(`Vietnam`, \n         month, \n         year) %&gt;%\n  filter(year &gt;= 2010)\n\n\n\n\nThe code chunk below uses group_by() and summarise() of dplyr to compute year average arrivals by month.\n\nhline.data &lt;- Vietnam %&gt;% \n  group_by(month) %&gt;%\n  summarise(avgvalue = mean(`Vietnam`))\n\n\n\n\nThe code chunk below is used to plot the cycle plot as shown in Slide 12/23.\n\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_tufte(base_family = \"Helvetica\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-slopegraph",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-slopegraph",
    "title": "Hands-on Exercise 06",
    "section": "",
    "text": "In this section we will learn how to plot a slopegraph by using R.\nBefore getting start, make sure that CGPfunctions has been installed and loaded onto R environment. Then, refer to Using newggslopegraph to learn more about the function. Lastly, read more about newggslopegraph() and its arguments by referring to this link.\n\n\nImport the rice data set into R environment by using the code chunk below.\n\nrice &lt;- read_csv(\"data/rice.csv\")\n\n\n\n\nNext, code chunk below will be used to plot a basic slopegraph as shown below.\n\nrice %&gt;% \n  mutate(Year = factor(Year)) %&gt;%\n  filter(Year %in% c(1961, 1980)) %&gt;%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Dr. Kam Tin Seong\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThings to learn from the code chunk\n\n\n\nFor effective data visualisation design, factor() is used convert the value type of Year field from numeric to factor."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex_2/Take-home_Ex_2.html",
    "href": "Take-home_Ex/Take-home_Ex_2/Take-home_Ex_2.html",
    "title": "Take-home Exercise 02",
    "section": "",
    "text": "pacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph, data.table, DT, visNetwork, tidyr)\n\n\nfilah &lt;- fromJSON(\"data/FILAH.json\")\n\n\nglimpse(filah)\n\nList of 5\n $ directed  : logi TRUE\n $ multigraph: logi TRUE\n $ graph     : Named list()\n $ nodes     :'data.frame': 396 obs. of  17 variables:\n  ..$ type       : chr [1:396] \"meeting\" \"meeting\" \"meeting\" \"meeting\" ...\n  ..$ date       : chr [1:396] \"Meeting 1\" \"Meeting 2\" \"Meeting 3\" \"Meeting 4\" ...\n  ..$ label      : chr [1:396] \"Meeting 1\" \"Meeting 2\" \"Meeting 3\" \"Meeting 4\" ...\n  ..$ id         : chr [1:396] \"Meeting_1\" \"Meeting_2\" \"Meeting_3\" \"Meeting_4\" ...\n  ..$ name       : chr [1:396] NA NA NA NA ...\n  ..$ role       : chr [1:396] NA NA NA NA ...\n  ..$ short_topic: chr [1:396] NA NA NA NA ...\n  ..$ long_topic : chr [1:396] NA NA NA NA ...\n  ..$ short_title: chr [1:396] NA NA NA NA ...\n  ..$ long_title : chr [1:396] NA NA NA NA ...\n  ..$ plan_type  : chr [1:396] NA NA NA NA ...\n  ..$ lat        : num [1:396] NA NA NA NA NA NA NA NA NA NA ...\n  ..$ lon        : num [1:396] NA NA NA NA NA NA NA NA NA NA ...\n  ..$ zone       : chr [1:396] NA NA NA NA ...\n  ..$ zone_detail: chr [1:396] NA NA NA NA ...\n  ..$ start      : chr [1:396] NA NA NA NA ...\n  ..$ end        : chr [1:396] NA NA NA NA ...\n $ links     :'data.frame': 765 obs. of  9 variables:\n  ..$ role     : chr [1:765] \"part_of\" \"part_of\" \"part_of\" \"part_of\" ...\n  ..$ source   : chr [1:765] \"Meeting_1\" \"Meeting_1\" \"Meeting_1\" \"Meeting_1\" ...\n  ..$ target   : chr [1:765] \"fish_vacuum_Meeting_1_Introduction_Discussion\" \"fish_vacuum_Meeting_1_Introduction\" \"seafood_festival_Meeting_1_Discussion\" \"seafood_festival_Meeting_1_Feasibility\" ...\n  ..$ key      : int [1:765] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ sentiment: num [1:765] NA NA NA NA NA NA NA NA NA NA ...\n  ..$ reason   : chr [1:765] NA NA NA NA ...\n  ..$ industry :List of 765\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. .. [list output truncated]\n  ..$ status   : chr [1:765] NA NA NA NA ...\n  ..$ time     : chr [1:765] NA NA NA NA ...\n\n\n\nnames(filah)\n\n[1] \"directed\"   \"multigraph\" \"graph\"      \"nodes\"      \"links\"     \n\nstr(filah, max.level =1)\n\nList of 5\n $ directed  : logi TRUE\n $ multigraph: logi TRUE\n $ graph     : Named list()\n $ nodes     :'data.frame': 396 obs. of  17 variables:\n $ links     :'data.frame': 765 obs. of  9 variables:\n\n\n\nfilah_nodes &lt;- as_tibble(filah$nodes)\nfilah_edges &lt;- as_tibble(filah$links)\n\nInital EDA\n\nExpCatViz(data=filah_nodes,\n          col=\"lightblue\")\n\n[[1]]\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\n\n[[3]]\n\n\n\n\n\n\n\n\n\n\n[[4]]\n\n\n\n\n\n\n\n\n\n\n[[5]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThings to Note: Summary of Node Attribute Exploration\n\n\n\n\nNode Type (type)\n\nNearly half of all nodes (48%) are trip nodes, indicating a strong focus on travel records.\n\nOther significant types include discussion (15%), place (15%), and plan (10%).\n\n3% of node types are missing (NA), which may require cleaning or tagging.\n\nRole (role)\n\n99% of nodes have missing role values, making it difficult to analyze by committee roles.\n\nOnly a small portion are labeled as Member or Committee Chair.\n\nRole information may need to be imputed, enriched, or excluded depending on analysis goals.\n\nPlan Type (plan_type)\n\n90% of plan nodes lack plan_type values.\n\nOnly a small percentage are labeled as Travel, Proposal, etc.\n\nThis limits the usefulness of this variable unless cleaned or externally enriched.\n\nZone (zone)\n\n82% of place nodes are missing zone classification.\n\nMost of the known zones are commercial (14%) with small amounts of industrial and tourism.\n\nThis hinders any meaningful zoning or geographic segmentation.\n\nZone Detail (zone_detail)\n\n98% of zone_detail entries are missing.\n\nOnly 2% are labeled restaurant.\n\nThis variable may not be useful without enrichment from other sources.\n\n\n\n\nOn the other hands, code chunk below uses ExpCATViz() of SmartEDA package to reveal the frequency distribution of all categorical fields in filah_edges tibble dataframe.\n\nExpCatViz(data=filah_edges,\n          col=\"lightblue\")\n\n[[1]]\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\n\n[[3]]"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#readings",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#readings",
    "title": "Hands-on Exercise 06",
    "section": "",
    "text": "A taxonomy of temporal data visualization techniques\nEdward Tufte’s “Slopegraphs”\nIntroduction to Cycle Plots\nVisualizing Change: An Innovation in Time-Series Analysis\nThe Development of the Horizon Graph\n\n\n\n\n\nwhat is a slopegraph?\nSlopegraph Update\nTime on the Horizon\nTimeSearcher\nWhat is a slopegraph?\nDonahue, Rafe M.J. Fundamental Statistical Concepts in Presenting Data: Principles for Constructing Better Graphics. This article provide a real world example of building truthful and functional time series graph.\nHockey stick graph at wiki.\nMichael E. Mann, Raymond S. Bradley, Malcolm K. Hughes (1999) “Northern hemisphere temperatures during the past millennium: Inferences, uncertainties, and limitations”. Geophysical Research Letters, Vol. 26, No. pp. 759-762.\nThe Guardian (2010) “Hockey stick graph took pride of place in IPCC report, despite doubts”."
  }
]